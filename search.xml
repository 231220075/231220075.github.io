<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React vs. Vue：前端框架的深度对决</title>
    <url>/2025/08/13/React-vs-Vue-%E6%B7%B1%E5%BA%A6%E5%AF%B9%E5%86%B3/</url>
    <content><![CDATA[在当今前端开发领域，React 和 Vue 无疑是两座无法绕开的高峰。它们都拥有庞大的社区、丰富的生态和出色的性能，但其设计哲学和开发体验却大相径庭。作为开发者，理解它们的核心差异，才能在项目选型时做出最明智的决策。本文将从专业角度，对这两个框架进行一次深度对比。
概览


特性
React
Vue



类型
用于构建用户界面的 JavaScript 库
渐进式 JavaScript 框架


核心思想
一切皆是 JavaScript，拥抱函数式编程
拥抱传统 Web，HTML&#x2F;CSS&#x2F;JS 分离


创建者
Meta (Facebook)
尤雨溪 (前 Google 工程师)


上手难度
较陡峭，需要深入理解 JS 和 JSX
相对平缓，对新手更友好


灵活性
极高，生态系统庞大，选择多样
较高，官方提供全家桶，开箱即用


数据流
单向数据流
支持单向和双向数据绑定


状态管理
Context API, Redux, MobX, Zustand
Pinia (官方推荐), Vuex


路由
React Router
Vue Router (官方)


构建工具
Create React App, Vite, Next.js
Vue CLI, Vite, Nuxt.js


市场份额
更大，尤其在欧美和大型企业
快速增长，在亚洲和初创公司中非常流行



1. 核心理念与设计哲学React：更像一个“库”，专注 UI
React 的核心定位是一个用于构建用户界面（UI）的 JavaScript 库。它本身只关心视图层（MVC 中的 V）。这意味着 React 只提供构建 UI 组件的核心功能。至于路由、状态管理、HTTP 请求等，你需要自己选择并集成第三方库。

All in JS：React 的一个核心哲学是“All in JS”。它认为模板逻辑和渲染逻辑本质上是耦合的，因此发明了 JSX（JavaScript XML），让你可以在 JavaScript 代码中直接编写类似 HTML 的结构。这提供了极大的灵活性和编程能力，因为你可以使用 JavaScript 的全部功能（如 map, filter）来构建 UI。
单向数据流：数据总是从父组件通过 props 流向子组件。子组件不能直接修改父组件的数据，需要通过调用父组件传递的回调函数来通知父组件进行更新。这种模式使得数据流向清晰可控，在大型应用中更容易追踪和调试。

Vue：一个“渐进式框架”
Vue 的定位是一个渐进式框架。这意味着你可以从一个简单的功能（比如只用它来处理页面上的一小块交互）开始，然后根据需求逐渐引入路由（Vue Router）、状态管理（Pinia）等功能，最终构建一个功能完整的单页应用（SPA）。

拥抱传统 Web：Vue 的设计对有传统 HTML&#x2F;CSS&#x2F;JS 背景的开发者非常友好。它的单文件组件 (SFC - Single File Component) 将一个组件的模板 (&lt;template&gt;)、脚本 (&lt;script&gt;) 和样式 (&lt;style&gt;) 封装在同一个 .vue 文件中。这种结构清晰，关注点分离，非常直观。
灵活的数据绑定：Vue 同时支持单向数据流和双向数据绑定。通过 v-model 指令，可以轻松实现表单输入和状态之间的双向绑定，这在处理表单时大大简化了代码。


2. 组件化开发两者都采用组件化思想，但实现方式不同。
React 组件：函数与 Hooks
现代 React 开发主要使用函数式组件和 Hooks。
// React Functional Component with Hooksimport React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;function MyComponent(&#123; initialCount &#125;) &#123;  const [count, setCount] = useState(initialCount); // 状态 Hook  const [data, setData] = useState(null);  // 副作用 Hook，类似生命周期函数  useEffect(() =&gt; &#123;    // 模拟数据获取    fetch(&#x27;https://api.example.com/data&#x27;)      .then(res =&gt; res.json())      .then(setData);  &#125;, []); // 空依赖数组表示只在组件挂载时运行一次  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;


优点：JSX 提供了无与伦比的灵活性。Hooks（如 useState, useEffect）让函数式组件也能拥有状态和生命周期逻辑，代码更简洁、复用性更强。
挑战：需要对 JavaScript 的闭包、this 指向（在类组件中）有深刻理解。JSX 的学习曲线对初学者来说可能稍高。

Vue 组件：选项式 API 与组合式 API
Vue 提供了两种组件 API 风格。

选项式 API (Options API)：对新手友好，结构清晰。
&lt;!-- MyComponent.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;initialCount&#x27;],  data() &#123;    return &#123;      count: this.initialCount,      data: null    &#125;;  &#125;,  methods: &#123;    increment() &#123;      this.count++;    &#125;  &#125;,  mounted() &#123;    // 模拟数据获取    fetch(&#x27;https://api.example.com/data&#x27;)      .then(res =&gt; res.json())      .then(data =&gt; this.data = data);  &#125;&#125;&lt;/script&gt;

组合式 API (Composition API)：受 React Hooks 启发，更适合大型复杂项目，逻辑组织更灵活。
&lt;!-- MyComponent.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;p&gt;Count: &#123;&#123; count &#125;&#125;&lt;/p&gt;    &lt;button @click=&quot;increment&quot;&gt;Increment&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;;const props = defineProps([&#x27;initialCount&#x27;]);const count = ref(props.initialCount); // 响应式状态const data = ref(null);function increment() &#123;  count.value++;&#125;onMounted(async () =&gt; &#123;  data.value = await (await fetch(&#x27;https://api.example.com/data&#x27;)).json();&#125;);&lt;/script&gt;


优点：.vue 文件结构清晰，模板语法更接近原生 HTML。组合式 API 解决了选项式 API 在大型组件中逻辑分散的问题，代码组织更灵活。
挑战：在组合式 API 中需要理解 ref 和 reactive 的区别。


3. 生态系统与状态管理React：庞大而分散，选择自由

状态管理：
简单场景：使用 useState 和 useReducer 配合 Context API。
复杂应用：Redux 是事实上的标准，功能强大，但以学习曲线陡峭和模板代码多而闻名。近年来，Zustand 和 MobX 等更轻量、更现代的方案越来越受欢迎。


生态：React 的生态系统是其最大的优势之一。几乎任何你能想到的功能都有成熟的第三方库支持。但也意味着你需要花时间去评估和选择技术栈，这被称为“选择疲劳症”。Next.js 框架的出现极大地改变了这一局面，它为 React 提供了一个强大的、带有一系列最佳实践的全栈开发骨架。

Vue：官方维护，集成度高

状态管理：
Pinia 是 Vue 3 的官方推荐方案（取代了 Vuex）。它设计极其简洁、类型友好，并且没有 mutations 的概念，上手非常快。


生态：Vue 的核心库（如 vue-router for routing, pinia for state management）都由官方团队维护。这保证了它们之间的高度协同和一致性。开发者不需要在众多选项中纠lge，可以快速开始。Nuxt.js 是 Vue 生态的“Next.js”，提供了服务端渲染（SSR）、静态站点生成（SSG）等高级功能。


4. 性能两者都使用了虚拟 DOM (Virtual DOM)，性能都非常出色，足以应对绝大多数应用场景。

React：通过 Fiber 架构实现了可中断的异步渲染，为将来的并发模式等高级功能铺平了道路。
Vue：在编译时进行了更多优化。它会静态分析模板，找出动态部分和静态部分，从而在更新时只对比动态节点，减少了虚拟 DOM diff 的开销。

在实际应用中，性能瓶颈更多地来自于应用本身的逻辑（如巨大的列表、频繁的非必要更新），而不是框架本身。

总结与选择建议
选择 React 的理由：

大型项目和团队：React 的单向数据流和庞大的生态系统非常适合构建复杂、可维护的大型企业级应用。
招聘市场：React 的岗位需求量目前是最大的，如果你想最大化就业机会，React 是一个稳妥的选择。
追求极致灵活性：如果你想完全掌控你的技术栈，自由组合各种库来构建应用，React 提供了这种自由。
跨平台开发：React Native 允许你使用 React 的知识来构建原生移动应用（iOS&#x2F;Android），这是一个巨大的加分项。


选择 Vue 的理由：

快速开发和上手：Vue 的学习曲线更平缓，文档极其出色，官方工具链开箱即用，非常适合初创公司、中小型项目和追求开发效率的场景。
对传统开发者友好：如果你有扎实的 HTML&#x2F;CSS&#x2F;JS 基础，Vue 的模板语法会让你感到非常亲切。
无缝集成：官方提供的路由和状态管理库与核心库无缝集成，减少了决策成本和集成问题。
性能：开箱即用的性能表现非常优秀，心智负担小。



最终，React 和 Vue 都是顶级的框架，没有绝对的好坏之分，只有“更适合”的选择。 最好的方式是都尝试一下，构建一个小项目，亲身感受它们的开发体验，然后根据你的项目需求和个人偏好做出决定。
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Vue</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解</title>
    <url>/2025/08/12/Java%20%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[📝 Java 注解完全指南
yys-project中延伸学习Java注解，上传一下

1. 什么是Java注解？Java注解（Annotation）是Java 5引入的一种元数据机制，它为代码提供了一种描述性的信息，而不直接影响代码的执行逻辑。可以把注解理解为”给代码贴标签”，这些标签可以被编译器、开发工具或运行时环境读取和处理。
注解的本质
注解本质上是一种特殊的接口
继承自java.lang.annotation.Annotation接口
在编译后会生成相应的字节码信息

2. Java注解 vs C++的对比


特性
Java注解
C++宏&#x2F;预处理指令
C++属性(C++11+)



语法
@注解名
#define, #pragma
[[属性名]]


处理时机
编译时&#x2F;运行时
预处理时
编译时


类型安全
强类型
弱类型
强类型


反射支持
完全支持
不支持
有限支持


功能范围
元数据、验证、代码生成
文本替换、条件编译
优化提示、属性标记


举例对比：Java注解：
@Overridepublic String toString() &#123;    return &quot;example&quot;;&#125;

C++属性：
[[override]]virtual std::string toString() &#123;    return &quot;example&quot;;&#125;

C++宏：
#define OVERRIDE virtualOVERRIDE std::string toString() &#123;    return &quot;example&quot;;&#125;

3. 注解的工作原理3.1 编译时处理// 源代码@Overridepublic void method() &#123;&#125;// 编译后的字节码中会包含注解信息// 可以通过反射API在运行时访问

3.2 三个处理阶段
源码阶段：注解存在于.java文件中
编译阶段：注解被编译器处理，可能生成额外代码
运行阶段：通过反射API读取注解信息

3.3 注解处理器（Annotation Processor）// 自定义注解处理器示例@SupportedAnnotationTypes(&quot;com.example.MyAnnotation&quot;)public class MyProcessor extends AbstractProcessor &#123;    @Override    public boolean process(Set&lt;? extends TypeElement&gt; annotations,                           RoundEnvironment roundEnv) &#123;        // 在编译时处理注解        return true;    &#125;&#125;

4. 注解的分类4.1 按生命周期分类SOURCE（源码级）@Retention(RetentionPolicy.SOURCE)public @interface SourceAnnotation &#123;    String value();&#125;

只在源码中存在，编译后丢弃
主要用于编译时检查
例如：@Override, @SuppressWarnings

CLASS（字节码级）@Retention(RetentionPolicy.CLASS)public @interface ClassAnnotation &#123;    String value();&#125;

在字节码中保留，但运行时不可访问
默认的保留策略
用于编译时或字节码处理工具

RUNTIME（运行时级）@Retention(RetentionPolicy.RUNTIME)public @interface RuntimeAnnotation &#123;    String value();&#125;

运行时可通过反射访问
最常用的类型
用于框架和库的运行时处理

4.2 按作用目标分类@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface MyAnnotation &#123;    // 可以用在类和方法上&#125;

常见的ElementType：

TYPE：类、接口、枚举
METHOD：方法
FIELD：字段
PARAMETER：参数
CONSTRUCTOR：构造器
PACKAGE：包

5. 常见内置注解详解5.1 基础注解@Overridepublic class Child extends Parent &#123;    @Override  // 确保正确重写父类方法    public void method() &#123;        System.out.println(&quot;子类实现&quot;);    &#125;&#125;
功能：

编译时检查是否正确重写了父类方法
提高代码可读性
防止方法签名错误

@Deprecatedpublic class OldAPI &#123;    @Deprecated(since = &quot;1.5&quot;, forRemoval = true)    public void oldMethod() &#123;        // 已废弃的方法    &#125;        public void newMethod() &#123;        // 推荐使用的新方法    &#125;&#125;
功能：

标记已废弃的API
编译时产生警告
可以指定废弃版本和是否将被移除

@SuppressWarningspublic class Example &#123;    @SuppressWarnings(&quot;unchecked&quot;)    public void method() &#123;        List list = new ArrayList();  // 原始类型警告被抑制        list.add(&quot;item&quot;);    &#125;        @SuppressWarnings(&#123;&quot;unused&quot;, &quot;deprecation&quot;&#125;)    private void anotherMethod() &#123;        // 抑制多种警告    &#125;&#125;
常用警告类型：

unchecked：未检查转换
unused：未使用的变量
deprecation：使用已废弃的API
rawtypes：使用原始类型

@SafeVarargspublic class VarargsExample &#123;    @SafeVarargs    public static &lt;T&gt; void printAll(T... items) &#123;        for (T item : items) &#123;            System.out.println(item);        &#125;    &#125;&#125;

5.2 函数式接口注解@FunctionalInterface 详细解释@FunctionalInterface注解用来标记一个接口是函数式接口，这是Java 8引入Lambda表达式后的重要概念。
什么是函数式接口？函数式接口是只有一个抽象方法的接口，它可以被Lambda表达式实现。
@FunctionalInterfacepublic interface Calculator &#123;    // 只能有一个抽象方法（核心要求）    int calculate(int a, int b);        // 可以有默认方法（不算抽象方法）    default void log() &#123;        System.out.println(&quot;计算完成&quot;);    &#125;        // 可以有静态方法（不算抽象方法）    static void info() &#123;        System.out.println(&quot;这是一个计算器接口&quot;);    &#125;&#125;

Lambda表达式实现传统方式 vs Lambda方式的对比：
// ❌ 传统方式：使用匿名内部类Calculator add = new Calculator() &#123;    @Override    public int calculate(int a, int b) &#123;        return a + b;    &#125;&#125;;// ✅ Lambda方式：简洁明了Calculator add = (a, b) -&gt; a + b;Calculator multiply = (a, b) -&gt; a * b;Calculator subtract = (a, b) -&gt; a - b;// 使用示例int result1 = add.calculate(5, 3);        // 结果：8int result2 = multiply.calculate(4, 6);   // 结果：24int result3 = subtract.calculate(10, 4);  // 结果：6

Lambda表达式语法详解// 完整语法：(参数列表) -&gt; &#123; 方法体 &#125;Calculator complex = (int a, int b) -&gt; &#123;    System.out.println(&quot;正在计算: &quot; + a + &quot; + &quot; + b);    int result = a + b;    return result;&#125;;// 简化语法：参数类型可以省略（类型推断）Calculator simple = (a, b) -&gt; a + b;// 单参数可以省略括号Function&lt;Integer, Integer&gt; square = x -&gt; x * x;// 无参数必须保留空括号Supplier&lt;String&gt; greeting = () -&gt; &quot;Hello World&quot;;// 单条语句可以省略大括号和returnCalculator add = (a, b) -&gt; a + b;// 多条语句必须使用大括号和returnCalculator verbose = (a, b) -&gt; &#123;    System.out.println(&quot;开始计算&quot;);    return a + b;&#125;;

常见的函数式接口Java提供了许多内置的函数式接口：
// 1. Supplier&lt;T&gt; - 供应商：无参数，返回T类型Supplier&lt;String&gt; stringSupplier = () -&gt; &quot;Hello&quot;;Supplier&lt;Integer&gt; randomNum = () -&gt; new Random().nextInt(100);// 2. Consumer&lt;T&gt; - 消费者：接受T类型参数，无返回值Consumer&lt;String&gt; printer = str -&gt; System.out.println(str);Consumer&lt;Integer&gt; logger = num -&gt; System.out.println(&quot;数字：&quot; + num);// 3. Function&lt;T, R&gt; - 函数：接受T类型，返回R类型Function&lt;String, Integer&gt; stringLength = str -&gt; str.length();Function&lt;Integer, String&gt; intToString = num -&gt; &quot;数字：&quot; + num;// 4. Predicate&lt;T&gt; - 断言：接受T类型，返回booleanPredicate&lt;String&gt; isEmpty = str -&gt; str.isEmpty();Predicate&lt;Integer&gt; isEven = num -&gt; num % 2 == 0;// 5. BiFunction&lt;T, U, R&gt; - 双参数函数：接受T和U，返回RBiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;BiFunction&lt;String, String, String&gt; concat = (s1, s2) -&gt; s1 + s2;

实际应用示例public class CalculatorDemo &#123;    public static void main(String[] args) &#123;        // 定义不同的计算方式        Calculator add = (a, b) -&gt; a + b;        Calculator multiply = (a, b) -&gt; a * b;        Calculator max = (a, b) -&gt; Math.max(a, b);                // 使用计算器        performCalculation(10, 5, add);      // 输出：结果：15        performCalculation(10, 5, multiply); // 输出：结果：50        performCalculation(10, 5, max);      // 输出：结果：10                // 集合操作中使用Lambda        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);                // 过滤偶数        List&lt;Integer&gt; evenNumbers = numbers.stream()            .filter(n -&gt; n % 2 == 0)            .collect(Collectors.toList());                // 平方运算        List&lt;Integer&gt; squares = numbers.stream()            .map(n -&gt; n * n)            .collect(Collectors.toList());                // 求和        int sum = numbers.stream()            .reduce(0, (a, b) -&gt; a + b);    &#125;        // 高阶函数：接受函数作为参数    public static void performCalculation(int a, int b, Calculator calc) &#123;        int result = calc.calculate(a, b);        System.out.println(&quot;结果：&quot; + result);        calc.log(); // 调用默认方法    &#125;&#125;

@FunctionalInterface注解的作用
编译时检查：确保接口只有一个抽象方法

@FunctionalInterfacepublic interface InvalidInterface &#123;    void method1();    void method2(); // 编译错误！函数式接口只能有一个抽象方法&#125;


文档说明：明确表示这是一个函数式接口
IDE支持：开发工具可以提供更好的Lambda支持

与传统接口的区别// 传统接口 - 可能有多个抽象方法public interface TraditionalInterface &#123;    void method1();    void method2();    void method3();&#125;// 函数式接口 - 只有一个抽象方法@FunctionalInterfacepublic interface FunctionalInterface &#123;    void singleMethod();        // 可以有默认方法和静态方法    default void defaultMethod() &#123;&#125;    static void staticMethod() &#123;&#125;&#125;

方法引用（Method Reference）Lambda表达式的进一步简化：
// Lambda表达式Function&lt;String, Integer&gt; lengthLambda = str -&gt; str.length();// 方法引用（更简洁）Function&lt;String, Integer&gt; lengthMethodRef = String::length;// 其他方法引用示例Consumer&lt;String&gt; printLambda = str -&gt; System.out.println(str);Consumer&lt;String&gt; printMethodRef = System.out::println;// 构造器引用Supplier&lt;ArrayList&lt;String&gt;&gt; listSupplier = ArrayList::new;

总结：@FunctionalInterface让Java支持函数式编程，使代码更简洁、更具表达力。Lambda表达式本质上是匿名函数的简写，让我们可以将行为作为参数传递，这是现代Java编程的重要特性！
6. 框架中的常用注解什么是Spring框架？Spring是Java企业级开发中最流行的应用框架，它提供了：

依赖注入（DI）：自动管理对象间的依赖关系
面向切面编程（AOP）：统一处理横切关注点（如日志、事务）
事务管理：简化数据库事务处理
Web开发支持：MVC架构支持

Spring Boot是Spring的进化版，它：

自动配置：根据依赖自动配置Spring应用
内嵌服务器：无需外部Tomcat，直接运行
简化配置：减少XML配置，基于注解开发
微服务友好：易于构建独立的微服务应用

6.1 Spring核心注解详解组件注解系列@Component - 通用组件注解/** * @Component: Spring的基础组件注解 * 功能：告诉Spring这是一个需要管理的Bean（对象） * 作用：Spring会自动创建这个类的实例，并放入容器中管理 */@Componentpublic class EmailService &#123;    public void sendEmail(String to, String message) &#123;        System.out.println(&quot;发送邮件到: &quot; + to);        System.out.println(&quot;内容: &quot; + message);    &#125;&#125;// 可以指定Bean的名称@Component(&quot;customEmailService&quot;)public class CustomEmailService &#123;    // Spring容器中这个Bean的名称是&quot;customEmailService&quot;&#125;

@Service - 业务逻辑层注解/** * @Service: 标记业务逻辑层组件 * 功能：本质上等同于@Component，但语义更明确 * 用途：处理业务逻辑、调用数据访问层、实现业务规则 */@Servicepublic class UserService &#123;        @Autowired    private UserRepository userRepository;        // 业务方法：创建用户    public User createUser(String username, String email) &#123;        // 业务逻辑：验证用户名是否重复        if (userRepository.existsByUsername(username)) &#123;            throw new IllegalArgumentException(&quot;用户名已存在&quot;);        &#125;                // 创建用户对象        User user = new User();        user.setUsername(username);        user.setEmail(email);        user.setCreatedAt(new Date());                // 保存到数据库        return userRepository.save(user);    &#125;        // 业务方法：用户登录验证    public boolean authenticate(String username, String password) &#123;        User user = userRepository.findByUsername(username);        return user != null &amp;&amp; user.getPassword().equals(password);    &#125;&#125;

@Repository - 数据访问层注解/** * @Repository: 标记数据访问层组件 * 功能： * 1. 等同于@Component，但语义更明确 * 2. 自动将数据访问异常转换为Spring的DataAccessException * 用途：处理数据库操作、文件操作等数据访问逻辑 */@Repositorypublic class UserRepository &#123;        @Autowired    private JdbcTemplate jdbcTemplate;        // 数据访问方法：根据ID查找用户    public User findById(Long id) &#123;        String sql = &quot;SELECT * FROM users WHERE id = ?&quot;;        return jdbcTemplate.queryForObject(sql, new Object[]&#123;id&#125;,             (rs, rowNum) -&gt; &#123;                User user = new User();                user.setId(rs.getLong(&quot;id&quot;));                user.setUsername(rs.getString(&quot;username&quot;));                user.setEmail(rs.getString(&quot;email&quot;));                return user;            &#125;);    &#125;        // 数据访问方法：保存用户    public User save(User user) &#123;        if (user.getId() == null) &#123;            // 新建用户            String sql = &quot;INSERT INTO users (username, email, created_at) VALUES (?, ?, ?)&quot;;            KeyHolder keyHolder = new GeneratedKeyHolder();            jdbcTemplate.update(connection -&gt; &#123;                PreparedStatement ps = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);                ps.setString(1, user.getUsername());                ps.setString(2, user.getEmail());                ps.setTimestamp(3, new Timestamp(user.getCreatedAt().getTime()));                return ps;            &#125;, keyHolder);            user.setId(keyHolder.getKey().longValue());        &#125; else &#123;            // 更新用户            String sql = &quot;UPDATE users SET username = ?, email = ? WHERE id = ?&quot;;            jdbcTemplate.update(sql, user.getUsername(), user.getEmail(), user.getId());        &#125;        return user;    &#125;        public boolean existsByUsername(String username) &#123;        String sql = &quot;SELECT COUNT(*) FROM users WHERE username = ?&quot;;        int count = jdbcTemplate.queryForObject(sql, Integer.class, username);        return count &gt; 0;    &#125;&#125;

@Controller - Web控制器注解/** * @Controller: 标记Web控制器组件 * 功能：处理HTTP请求，返回视图（如JSP、Thymeleaf模板） * 用途：传统的MVC架构中的Controller层 */@Controller@RequestMapping(&quot;/web&quot;)public class WebController &#123;        @Autowired    private UserService userService;        // 处理GET请求，返回用户列表页面    @GetMapping(&quot;/users&quot;)    public String listUsers(Model model) &#123;        List&lt;User&gt; users = userService.getAllUsers();        model.addAttribute(&quot;users&quot;, users);        return &quot;user-list&quot;; // 返回视图名称，对应user-list.html模板    &#125;        // 处理GET请求，显示用户详情页面    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public String userDetail(@PathVariable Long id, Model model) &#123;        User user = userService.findById(id);        model.addAttribute(&quot;user&quot;, user);        return &quot;user-detail&quot;; // 返回user-detail.html模板    &#125;        // 处理POST请求，创建用户后重定向    @PostMapping(&quot;/users&quot;)    public String createUser(@ModelAttribute User user) &#123;        userService.createUser(user.getUsername(), user.getEmail());        return &quot;redirect:/web/users&quot;; // 重定向到用户列表页面    &#125;&#125;

依赖注入注解@Autowired - 自动装配注解/** * @Autowired: 自动依赖注入注解 * 功能：Spring自动查找匹配的Bean并注入 * 原理：按类型（Type）匹配，如果有多个同类型Bean则按名称匹配 */@Servicepublic class OrderService &#123;        // 1. 字段注入（最常用，但不推荐用于测试）    @Autowired    private UserService userService;        @Autowired    private PaymentService paymentService;        // 2. 构造器注入（推荐方式，便于测试和确保依赖不为null）    private final EmailService emailService;    private final InventoryService inventoryService;        @Autowired    public OrderService(EmailService emailService, InventoryService inventoryService) &#123;        this.emailService = emailService;        this.inventoryService = inventoryService;    &#125;        // 3. Setter注入（可选依赖）    private NotificationService notificationService;        @Autowired(required = false) // required=false表示这个依赖是可选的    public void setNotificationService(NotificationService notificationService) &#123;        this.notificationService = notificationService;    &#125;        public Order createOrder(Long userId, List&lt;OrderItem&gt; items) &#123;        // 使用注入的依赖        User user = userService.findById(userId);                // 检查库存        for (OrderItem item : items) &#123;            if (!inventoryService.isAvailable(item.getProductId(), item.getQuantity())) &#123;                throw new RuntimeException(&quot;库存不足&quot;);            &#125;        &#125;                // 创建订单        Order order = new Order();        order.setUser(user);        order.setItems(items);        order.setStatus(&quot;CREATED&quot;);                // 处理支付        boolean paymentSuccess = paymentService.processPayment(order.getTotalAmount());        if (paymentSuccess) &#123;            order.setStatus(&quot;PAID&quot;);                        // 发送邮件通知            emailService.sendEmail(user.getEmail(), &quot;订单创建成功&quot;);                        // 可选的通知服务            if (notificationService != null) &#123;                notificationService.sendPushNotification(user.getId(), &quot;您的订单已创建&quot;);            &#125;        &#125;                return order;    &#125;&#125;

@Qualifier - 指定具体Bean/** * @Qualifier: 当有多个同类型Bean时，指定要注入哪一个 * 场景：一个接口有多个实现类 */// 接口public interface PaymentService &#123;    boolean processPayment(BigDecimal amount);&#125;// 实现类1@Service(&quot;alipayService&quot;)public class AlipayService implements PaymentService &#123;    public boolean processPayment(BigDecimal amount) &#123;        System.out.println(&quot;使用支付宝支付: &quot; + amount);        return true;    &#125;&#125;// 实现类2@Service(&quot;wechatPayService&quot;)public class WechatPayService implements PaymentService &#123;    public boolean processPayment(BigDecimal amount) &#123;        System.out.println(&quot;使用微信支付: &quot; + amount);        return true;    &#125;&#125;// 使用时指定具体的实现@Servicepublic class OrderService &#123;        @Autowired    @Qualifier(&quot;alipayService&quot;) // 明确指定使用支付宝服务    private PaymentService paymentService;        // 或者使用构造器注入    public OrderService(@Qualifier(&quot;wechatPayService&quot;) PaymentService paymentService) &#123;        this.paymentService = paymentService;    &#125;&#125;

@Value - 属性值注入/** * @Value: 注入配置文件中的属性值 * 功能：从application.properties或application.yml读取配置 */// application.properties文件内容：// app.name=我的应用// app.version=1.0.0// database.url=jdbc:mysql://localhost:3306/mydb// email.smtp.host=smtp.gmail.com// email.smtp.port=587@Servicepublic class ConfigService &#123;        // 注入简单属性值    @Value(&quot;$&#123;app.name&#125;&quot;)    private String appName;        @Value(&quot;$&#123;app.version&#125;&quot;)    private String appVersion;        // 注入数字类型    @Value(&quot;$&#123;email.smtp.port&#125;&quot;)    private int smtpPort;        // 提供默认值（如果配置文件中没有该属性）    @Value(&quot;$&#123;app.debug:false&#125;&quot;) // 默认值为false    private boolean debugMode;        @Value(&quot;$&#123;app.max-users:1000&#125;&quot;) // 默认值为1000    private int maxUsers;        // 注入系统属性    @Value(&quot;$&#123;java.version&#125;&quot;)    private String javaVersion;        // 注入环境变量    @Value(&quot;$&#123;HOME&#125;&quot;) // Unix/Linux系统的HOME环境变量    private String homeDirectory;        public void printConfig() &#123;        System.out.println(&quot;应用名称: &quot; + appName);        System.out.println(&quot;应用版本: &quot; + appVersion);        System.out.println(&quot;SMTP端口: &quot; + smtpPort);        System.out.println(&quot;调试模式: &quot; + debugMode);        System.out.println(&quot;最大用户数: &quot; + maxUsers);        System.out.println(&quot;Java版本: &quot; + javaVersion);        System.out.println(&quot;主目录: &quot; + homeDirectory);    &#125;&#125;

6.2 Spring Boot注解详解@SpringBootApplication - 启动类注解/** * @SpringBootApplication: Spring Boot应用的核心注解 * 功能：这是一个组合注解，等价于以下三个注解的组合： * 1. @Configuration: 标记这是一个配置类 * 2. @EnableAutoConfiguration: 启用Spring Boot的自动配置 * 3. @ComponentScan: 启用组件扫描 */@SpringBootApplicationpublic class MyApplication &#123;    public static void main(String[] args) &#123;        // 启动Spring Boot应用        SpringApplication.run(MyApplication.class, args);                /*         * 这一行代码会：         * 1. 创建Spring应用上下文         * 2. 扫描当前包及子包中的@Component、@Service等注解         * 3. 根据classpath中的依赖自动配置Bean         * 4. 启动内嵌的Web服务器（如Tomcat）         * 5. 部署应用到服务器上         */    &#125;&#125;// 如果需要自定义配置，可以分别使用：@Configuration@EnableAutoConfiguration@ComponentScan(basePackages = &#123;&quot;com.example.service&quot;, &quot;com.example.repository&quot;&#125;)public class CustomApplication &#123;    // 自定义配置&#125;

REST API注解系列@RestController - REST控制器注解/** * @RestController: REST API控制器注解 * 功能：等价于 @Controller + @ResponseBody * 特点：方法返回的对象会自动转换为JSON格式返回给客户端 * 用途：构建RESTful Web服务 */@RestController@RequestMapping(&quot;/api/v1&quot;) // 基础路径public class UserRestController &#123;        @Autowired    private UserService userService;        /**     * GET /api/v1/users - 获取所有用户     * 返回JSON格式的用户列表     */    @GetMapping(&quot;/users&quot;)    public List&lt;User&gt; getAllUsers() &#123;        return userService.getAllUsers();        // Spring会自动将List&lt;User&gt;转换为JSON数组返回    &#125;        /**     * GET /api/v1/users/123 - 根据ID获取用户     * @PathVariable: 从URL路径中提取参数     */    @GetMapping(&quot;/users/&#123;id&#125;&quot;)    public ResponseEntity&lt;User&gt; getUserById(@PathVariable Long id) &#123;        try &#123;            User user = userService.findById(id);            return ResponseEntity.ok(user); // 返回200状态码和用户数据        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.notFound().build(); // 返回404状态码        &#125;    &#125;        /**     * POST /api/v1/users - 创建新用户     * @RequestBody: 将请求体中的JSON转换为Java对象     */    @PostMapping(&quot;/users&quot;)    public ResponseEntity&lt;User&gt; createUser(@RequestBody CreateUserRequest request) &#123;        try &#123;            User user = userService.createUser(request.getUsername(), request.getEmail());            return ResponseEntity.status(HttpStatus.CREATED).body(user); // 返回201状态码        &#125; catch (IllegalArgumentException e) &#123;            return ResponseEntity.badRequest().build(); // 返回400状态码        &#125;    &#125;        /**     * PUT /api/v1/users/123 - 更新用户信息     */    @PutMapping(&quot;/users/&#123;id&#125;&quot;)    public ResponseEntity&lt;User&gt; updateUser(@PathVariable Long id,                                          @RequestBody UpdateUserRequest request) &#123;        try &#123;            User user = userService.updateUser(id, request.getUsername(), request.getEmail());            return ResponseEntity.ok(user);        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.notFound().build();        &#125;    &#125;        /**     * DELETE /api/v1/users/123 - 删除用户     */    @DeleteMapping(&quot;/users/&#123;id&#125;&quot;)    public ResponseEntity&lt;Void&gt; deleteUser(@PathVariable Long id) &#123;        try &#123;            userService.deleteUser(id);            return ResponseEntity.noContent().build(); // 返回204状态码        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.notFound().build();        &#125;    &#125;        /**     * GET /api/v1/users?page=0&amp;size=10&amp;sort=username - 分页查询     * @RequestParam: 从URL查询参数中提取值     */    @GetMapping(&quot;/users&quot;)    public ResponseEntity&lt;Page&lt;User&gt;&gt; getUsers(            @RequestParam(defaultValue = &quot;0&quot;) int page,            @RequestParam(defaultValue = &quot;10&quot;) int size,            @RequestParam(defaultValue = &quot;id&quot;) String sort) &#123;                PageRequest pageRequest = PageRequest.of(page, size, Sort.by(sort));        Page&lt;User&gt; users = userService.getUsers(pageRequest);        return ResponseEntity.ok(users);    &#125;&#125;

HTTP方法映射注解详解/** * HTTP方法映射注解详解 */@RestController@RequestMapping(&quot;/api/products&quot;)public class ProductController &#123;        /**     * @GetMapping: 处理GET请求     * 用途：获取资源，不会修改服务器状态     * 特点：幂等（多次调用结果相同）、可缓存     */    @GetMapping // 等价于 @RequestMapping(method = RequestMethod.GET)    public List&lt;Product&gt; getAllProducts() &#123;        return productService.findAll();    &#125;        @GetMapping(&quot;/&#123;id&#125;&quot;)    public Product getProduct(@PathVariable Long id) &#123;        return productService.findById(id);    &#125;        /**     * @PostMapping: 处理POST请求     * 用途：创建新资源     * 特点：非幂等（多次调用可能产生不同结果）     */    @PostMapping    public ResponseEntity&lt;Product&gt; createProduct(@RequestBody Product product) &#123;        Product created = productService.save(product);        return ResponseEntity.status(HttpStatus.CREATED).body(created);    &#125;        /**     * @PutMapping: 处理PUT请求     * 用途：完整更新资源（替换整个资源）     * 特点：幂等     */    @PutMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Product&gt; updateProduct(@PathVariable Long id,                                                @RequestBody Product product) &#123;        product.setId(id);        Product updated = productService.save(product);        return ResponseEntity.ok(updated);    &#125;        /**     * @PatchMapping: 处理PATCH请求     * 用途：部分更新资源（只更新指定字段）     * 特点：幂等     */    @PatchMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Product&gt; patchProduct(@PathVariable Long id,                                               @RequestBody Map&lt;String, Object&gt; updates) &#123;        Product updated = productService.partialUpdate(id, updates);        return ResponseEntity.ok(updated);    &#125;        /**     * @DeleteMapping: 处理DELETE请求     * 用途：删除资源     * 特点：幂等     */    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;Void&gt; deleteProduct(@PathVariable Long id) &#123;        productService.delete(id);        return ResponseEntity.noContent().build();    &#125;&#125;

参数绑定注解详解@RestController@RequestMapping(&quot;/api/search&quot;)public class SearchController &#123;        /**     * @PathVariable: 从URL路径中提取变量     * URL示例: /api/search/users/123/orders/456     */    @GetMapping(&quot;/users/&#123;userId&#125;/orders/&#123;orderId&#125;&quot;)    public Order getUserOrder(@PathVariable Long userId,                             @PathVariable Long orderId) &#123;        return orderService.findByUserIdAndOrderId(userId, orderId);    &#125;        // 路径变量名称与参数名不同时    @GetMapping(&quot;/products/&#123;productId&#125;&quot;)    public Product getProduct(@PathVariable(&quot;productId&quot;) Long id) &#123;        return productService.findById(id);    &#125;        /**     * @RequestParam: 从URL查询参数中提取值     * URL示例: /api/search/products?keyword=手机&amp;category=电子&amp;minPrice=1000&amp;maxPrice=5000     */    @GetMapping(&quot;/products&quot;)    public List&lt;Product&gt; searchProducts(            @RequestParam String keyword,                    // 必需参数            @RequestParam(required = false) String category, // 可选参数            @RequestParam(defaultValue = &quot;0&quot;) BigDecimal minPrice, // 有默认值            @RequestParam(defaultValue = &quot;999999&quot;) BigDecimal maxPrice) &#123;                return productService.search(keyword, category, minPrice, maxPrice);    &#125;        /**     * @RequestHeader: 从HTTP请求头中提取值     */    @GetMapping(&quot;/secure-data&quot;)    public ResponseEntity&lt;String&gt; getSecureData(            @RequestHeader(&quot;Authorization&quot;) String authToken,            @RequestHeader(value = &quot;User-Agent&quot;, required = false) String userAgent,            @RequestHeader(defaultValue = &quot;application/json&quot;) String accept) &#123;                if (!isValidToken(authToken)) &#123;            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();        &#125;                return ResponseEntity.ok(&quot;安全数据&quot;);    &#125;        /**     * @RequestBody: 将请求体内容绑定到对象     * 常用于POST/PUT请求，自动将JSON转换为Java对象     */    @PostMapping(&quot;/users&quot;)    public User createUser(@RequestBody CreateUserRequest request) &#123;        // Spring自动将请求体中的JSON转换为CreateUserRequest对象        return userService.createUser(request);    &#125;        /**     * @ModelAttribute: 将请求参数绑定到对象（适用于表单提交）     * 适用于传统的表单提交，参数以key=value形式提交     */    @PostMapping(&quot;/users/form&quot;)    public String createUserForm(@ModelAttribute User user, Model model) &#123;        User created = userService.save(user);        model.addAttribute(&quot;user&quot;, created);        return &quot;user-created&quot;; // 返回视图名称    &#125;&#125;

REST API完整示例/** * 完整的REST API示例：用户管理 * 展示了标准的RESTful设计模式 */@RestController@RequestMapping(&quot;/api/v1/users&quot;)@Validated // 启用参数验证public class UserApiController &#123;        @Autowired    private UserService userService;        // GET /api/v1/users - 获取用户列表（支持分页和搜索）    @GetMapping    public ResponseEntity&lt;ApiResponse&lt;Page&lt;UserDto&gt;&gt;&gt; getUsers(            @RequestParam(defaultValue = &quot;0&quot;) int page,            @RequestParam(defaultValue = &quot;10&quot;) int size,            @RequestParam(defaultValue = &quot;id&quot;) String sort,            @RequestParam(defaultValue = &quot;asc&quot;) String direction,            @RequestParam(required = false) String search) &#123;                Sort.Direction sortDirection = &quot;desc&quot;.equalsIgnoreCase(direction) ?                                      Sort.Direction.DESC : Sort.Direction.ASC;        Pageable pageable = PageRequest.of(page, size, Sort.by(sortDirection, sort));                Page&lt;UserDto&gt; users = userService.findUsers(search, pageable);                ApiResponse&lt;Page&lt;UserDto&gt;&gt; response = ApiResponse.&lt;Page&lt;UserDto&gt;&gt;builder()            .success(true)            .message(&quot;用户列表获取成功&quot;)            .data(users)            .timestamp(LocalDateTime.now())            .build();                    return ResponseEntity.ok(response);    &#125;        // GET /api/v1/users/123 - 获取单个用户    @GetMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;ApiResponse&lt;UserDto&gt;&gt; getUser(@PathVariable Long id) &#123;        try &#123;            UserDto user = userService.findById(id);            return ResponseEntity.ok(ApiResponse.success(&quot;用户信息获取成功&quot;, user));        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.status(HttpStatus.NOT_FOUND)                .body(ApiResponse.error(&quot;用户不存在&quot;, null));        &#125;    &#125;        // POST /api/v1/users - 创建用户    @PostMapping    public ResponseEntity&lt;ApiResponse&lt;UserDto&gt;&gt; createUser(            @Valid @RequestBody CreateUserRequest request) &#123;        try &#123;            UserDto user = userService.createUser(request);            return ResponseEntity.status(HttpStatus.CREATED)                .body(ApiResponse.success(&quot;用户创建成功&quot;, user));        &#125; catch (DuplicateUsernameException e) &#123;            return ResponseEntity.status(HttpStatus.CONFLICT)                .body(ApiResponse.error(&quot;用户名已存在&quot;, null));        &#125;    &#125;        // PUT /api/v1/users/123 - 更新用户    @PutMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;ApiResponse&lt;UserDto&gt;&gt; updateUser(            @PathVariable Long id,            @Valid @RequestBody UpdateUserRequest request) &#123;        try &#123;            UserDto user = userService.updateUser(id, request);            return ResponseEntity.ok(ApiResponse.success(&quot;用户更新成功&quot;, user));        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.status(HttpStatus.NOT_FOUND)                .body(ApiResponse.error(&quot;用户不存在&quot;, null));        &#125;    &#125;        // DELETE /api/v1/users/123 - 删除用户    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; deleteUser(@PathVariable Long id) &#123;        try &#123;            userService.deleteUser(id);            return ResponseEntity.ok(ApiResponse.success(&quot;用户删除成功&quot;, null));        &#125; catch (UserNotFoundException e) &#123;            return ResponseEntity.status(HttpStatus.NOT_FOUND)                .body(ApiResponse.error(&quot;用户不存在&quot;, null));        &#125;    &#125;        // POST /api/v1/users/123/avatar - 上传用户头像    @PostMapping(&quot;/&#123;id&#125;/avatar&quot;)    public ResponseEntity&lt;ApiResponse&lt;String&gt;&gt; uploadAvatar(            @PathVariable Long id,            @RequestParam(&quot;file&quot;) MultipartFile file) &#123;        try &#123;            String avatarUrl = userService.uploadAvatar(id, file);            return ResponseEntity.ok(ApiResponse.success(&quot;头像上传成功&quot;, avatarUrl));        &#125; catch (Exception e) &#123;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)                .body(ApiResponse.error(&quot;头像上传失败&quot;, null));        &#125;    &#125;&#125;// 统一的API响应格式@Data@Builderpublic class ApiResponse&lt;T&gt; &#123;    private boolean success;    private String message;    private T data;    private LocalDateTime timestamp;        public static &lt;T&gt; ApiResponse&lt;T&gt; success(String message, T data) &#123;        return ApiResponse.&lt;T&gt;builder()            .success(true)            .message(message)            .data(data)            .timestamp(LocalDateTime.now())            .build();    &#125;        public static &lt;T&gt; ApiResponse&lt;T&gt; error(String message, T data) &#123;        return ApiResponse.&lt;T&gt;builder()            .success(false)            .message(message)            .data(data)            .timestamp(LocalDateTime.now())            .build();    &#125;&#125;

6.3 JPA&#x2F;Hibernate注解详解**JPA（Java Persistence API）**是Java的数据持久化标准，Hibernate是JPA的最流行实现。这些注解用于将Java对象映射到数据库表。
核心实体注解@Entity - 实体类注解/** * @Entity: 标记这是一个JPA实体类 * 功能：告诉JPA这个类对应数据库中的一张表 * 要求： * 1. 必须有一个无参构造器 * 2. 必须有一个主键字段（用@Id标记） * 3. 字段不能是final的 */@Entity@Table(name = &quot;users&quot;) // 可选：指定数据库表名，不指定则使用类名public class User &#123;        @Id // 标记主键字段    @GeneratedValue(strategy = GenerationType.IDENTITY) // 主键生成策略    private Long id;        @Column(name = &quot;username&quot;, nullable = false, unique = true, length = 50)    private String username;        @Column(name = &quot;email&quot;)    private String email;        @Column(name = &quot;created_at&quot;)    private LocalDateTime createdAt;        // 必须有无参构造器    public User() &#123;&#125;        public User(String username, String email) &#123;        this.username = username;        this.email = email;        this.createdAt = LocalDateTime.now();    &#125;        // getter和setter方法...&#125;

@Table - 表映射注解/** * @Table: 指定实体对应的数据库表的详细信息 */@Entity@Table(    name = &quot;user_profiles&quot;,           // 表名    catalog = &quot;myapp_db&quot;,            // 数据库名（可选）    schema = &quot;public&quot;,               // 模式名（可选）    uniqueConstraints = &#123;            // 唯一约束        @UniqueConstraint(            name = &quot;uk_user_email&quot;,             columnNames = &#123;&quot;user_id&quot;, &quot;email&quot;&#125;        )    &#125;,    indexes = &#123;                      // 索引        @Index(name = &quot;idx_user_email&quot;, columnList = &quot;email&quot;),        @Index(name = &quot;idx_user_created&quot;, columnList = &quot;created_at&quot;)    &#125;)public class UserProfile &#123;    // 字段定义...&#125;

@Id 和主键生成策略@Entitypublic class Product &#123;        /**     * @Id: 标记主键字段     * @GeneratedValue: 主键值生成策略     */        // 策略1: AUTO - 让JPA自动选择合适的策略    @Id    @GeneratedValue(strategy = GenerationType.AUTO)    private Long id;        // 策略2: IDENTITY - 使用数据库的自增字段（MySQL的AUTO_INCREMENT）    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        // 策略3: SEQUENCE - 使用数据库序列（Oracle、PostgreSQL）    @Id    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = &quot;product_seq&quot;)    @SequenceGenerator(name = &quot;product_seq&quot;, sequenceName = &quot;product_sequence&quot;, allocationSize = 1)    private Long id;        // 策略4: TABLE - 使用单独的表来生成主键    @Id    @GeneratedValue(strategy = GenerationType.TABLE, generator = &quot;product_gen&quot;)    @TableGenerator(name = &quot;product_gen&quot;, table = &quot;id_generator&quot;,                    pkColumnName = &quot;gen_name&quot;, valueColumnName = &quot;gen_value&quot;,                   pkColumnValue = &quot;product_id&quot;, allocationSize = 1)    private Long id;        // 复合主键：使用@IdClass或@EmbeddedId    // 方式1: @IdClass    @Id    private Long userId;    @Id    private Long productId;        // 字段定义...&#125;// 复合主键类@IdClass(UserProductId.class)@Entitypublic class UserProduct &#123;    @Id    private Long userId;    @Id    private Long productId;    private Integer quantity;    // ...&#125;// 主键类必须实现Serializablepublic class UserProductId implements Serializable &#123;    private Long userId;    private Long productId;        // 必须重写equals和hashCode    @Override    public boolean equals(Object o) &#123; /* ... */ &#125;        @Override    public int hashCode() &#123; /* ... */ &#125;&#125;

@Column - 字段映射注解@Entitypublic class User &#123;        /**     * @Column: 指定字段映射到数据库列的详细信息     */        // 基本用法    @Column(name = &quot;user_name&quot;)  // 指定数据库列名    private String username;        // 详细配置    @Column(        name = &quot;email_address&quot;,      // 列名        nullable = false,            // 不能为null（相当于NOT NULL约束）        unique = true,              // 唯一约束        length = 255,               // 字符串长度（varchar(255)）        columnDefinition = &quot;TEXT&quot;   // 自定义列定义    )    private String email;        // 数字类型配置    @Column(        name = &quot;salary&quot;,        precision = 10,  // 总位数        scale = 2        // 小数位数（decimal(10,2)）    )    private BigDecimal salary;        // 不需要映射到数据库的字段    @Transient    private String tempPassword; // 这个字段不会保存到数据库        // 时间类型    @Column(name = &quot;birth_date&quot;)    @Temporal(TemporalType.DATE)      // 只保存日期部分    private Date birthDate;        @Column(name = &quot;created_at&quot;)    @Temporal(TemporalType.TIMESTAMP) // 保存日期和时间    private Date createdAt;        @Column(name = &quot;login_time&quot;)    @Temporal(TemporalType.TIME)      // 只保存时间部分    private Date loginTime;        // 枚举类型    @Enumerated(EnumType.STRING)      // 保存枚举的字符串值    private UserStatus status;        // 如：ACTIVE, INACTIVE, BANNED        @Enumerated(EnumType.ORDINAL)     // 保存枚举的序号值    private UserRole role;            // 如：0, 1, 2        // 大对象类型    @Lob  // Large Object：用于存储大文本或二进制数据    @Column(name = &quot;profile_photo&quot;)    private byte[] photo;             // 存储图片        @Lob    @Column(name = &quot;description&quot;)    private String description;       // 存储长文本&#125;// 枚举类型示例public enum UserStatus &#123;    ACTIVE, INACTIVE, BANNED, SUSPENDED&#125;public enum UserRole &#123;    USER, ADMIN, MODERATOR&#125;

关联关系注解@OneToOne - 一对一关系/** * 一对一关系：一个用户对应一个用户详情 */// 主表（拥有外键的一方）@Entitypublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String username;        /**     * @OneToOne: 一对一关系     * @JoinColumn: 指定外键列     */    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)    @JoinColumn(name = &quot;profile_id&quot;, referencedColumnName = &quot;id&quot;)    private UserProfile profile;        // 构造器、getter、setter...&#125;// 从表@Entitypublic class UserProfile &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String firstName;    private String lastName;    private String bio;    private String avatarUrl;        // 双向关联：从UserProfile也能访问User    @OneToOne(mappedBy = &quot;profile&quot;) // mappedBy指向User类中的profile字段    private User user;        // 构造器、getter、setter...&#125;// 使用示例@Servicepublic class UserService &#123;        @Autowired    private UserRepository userRepository;        public User createUserWithProfile(String username, String firstName, String lastName) &#123;        // 创建用户详情        UserProfile profile = new UserProfile();        profile.setFirstName(firstName);        profile.setLastName(lastName);                // 创建用户        User user = new User();        user.setUsername(username);        user.setProfile(profile);                // 设置双向关联        profile.setUser(user);                // 由于设置了cascade = CascadeType.ALL，保存user时会自动保存profile        return userRepository.save(user);    &#125;&#125;

@OneToMany - 一对多关系/** * 一对多关系：一个用户可以有多个订单 */// &quot;一&quot;的一方：User@Entitypublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String username;        /**     * @OneToMany: 一对多关系     * mappedBy: 指向Order类中的user字段（表示外键在Order表中）     * cascade: 级联操作（保存用户时自动处理订单）     * fetch: 加载策略（LAZY表示需要时才加载订单列表）     */    @OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private List&lt;Order&gt; orders = new ArrayList&lt;&gt;();        // 便利方法：添加订单    public void addOrder(Order order) &#123;        orders.add(order);        order.setUser(this); // 设置双向关联    &#125;        // 便利方法：移除订单    public void removeOrder(Order order) &#123;        orders.remove(order);        order.setUser(null);    &#125;&#125;// &quot;多&quot;的一方：Order@Entitypublic class Order &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private BigDecimal totalAmount;    private LocalDateTime orderTime;        /**     * @ManyToOne: 多对一关系（从Order的角度看，多个订单对应一个用户）     * @JoinColumn: 指定外键列名     */    @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name = &quot;user_id&quot;, nullable = false)    private User user;        // 构造器、getter、setter...&#125;// 使用示例@Servicepublic class OrderService &#123;        public Order createOrder(Long userId, BigDecimal amount) &#123;        User user = userRepository.findById(userId)            .orElseThrow(() -&gt; new UserNotFoundException(&quot;用户不存在&quot;));                Order order = new Order();        order.setTotalAmount(amount);        order.setOrderTime(LocalDateTime.now());                // 建立关联关系        user.addOrder(order);                return orderRepository.save(order);    &#125;        // 获取用户的所有订单    public List&lt;Order&gt; getUserOrders(Long userId) &#123;        User user = userRepository.findById(userId)            .orElseThrow(() -&gt; new UserNotFoundException(&quot;用户不存在&quot;));                // 由于使用了LAZY加载，这里会触发数据库查询        return user.getOrders();    &#125;&#125;

@ManyToMany - 多对多关系/** * 多对多关系：用户和角色的关系（一个用户可以有多个角色，一个角色可以分配给多个用户） */// 主控方：User@Entitypublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String username;        /**     * @ManyToMany: 多对多关系     * @JoinTable: 指定中间表的信息     */    @ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;, fetch = FetchType.LAZY)    @JoinTable(        name = &quot;user_roles&quot;,                    // 中间表名        joinColumns = @JoinColumn(name = &quot;user_id&quot;),     // 当前实体的外键列        inverseJoinColumns = @JoinColumn(name = &quot;role_id&quot;) // 关联实体的外键列    )    private Set&lt;Role&gt; roles = new HashSet&lt;&gt;();        // 便利方法：添加角色    public void addRole(Role role) &#123;        roles.add(role);        role.getUsers().add(this);    &#125;        // 便利方法：移除角色    public void removeRole(Role role) &#123;        roles.remove(role);        role.getUsers().remove(this);    &#125;&#125;// 被控方：Role@Entitypublic class Role &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        private String name; // ADMIN, USER, MODERATOR等    private String description;        /**     * mappedBy: 指向User类中的roles字段，表示这是关系的被控方     */    @ManyToMany(mappedBy = &quot;roles&quot;)    private Set&lt;User&gt; users = new HashSet&lt;&gt;();        // 构造器、getter、setter...&#125;// 带额外信息的多对多关系：用户和课程的关系（包含注册时间、成绩等额外信息）@Entitypublic class User &#123;    @Id    private Long id;    private String username;        @OneToMany(mappedBy = &quot;user&quot;, cascade = CascadeType.ALL)    private Set&lt;UserCourse&gt; userCourses = new HashSet&lt;&gt;();&#125;@Entitypublic class Course &#123;    @Id    private Long id;    private String name;        @OneToMany(mappedBy = &quot;course&quot;, cascade = CascadeType.ALL)    private Set&lt;UserCourse&gt; userCourses = new HashSet&lt;&gt;();&#125;// 中间实体：包含额外信息@Entity@Table(name = &quot;user_courses&quot;)public class UserCourse &#123;        @EmbeddedId    private UserCourseId id;        @ManyToOne    @MapsId(&quot;userId&quot;) // 映射到复合主键的userId部分    @JoinColumn(name = &quot;user_id&quot;)    private User user;        @ManyToOne    @MapsId(&quot;courseId&quot;) // 映射到复合主键的courseId部分    @JoinColumn(name = &quot;course_id&quot;)    private Course course;        // 额外信息    private LocalDateTime enrollmentDate;    private BigDecimal grade;    private String status; // ENROLLED, COMPLETED, DROPPED        // 构造器、getter、setter...&#125;// 复合主键@Embeddablepublic class UserCourseId implements Serializable &#123;    private Long userId;    private Long courseId;        // 必须重写equals和hashCode    @Override    public boolean equals(Object o) &#123; /* ... */ &#125;        @Override    public int hashCode() &#123; /* ... */ &#125;&#125;

级联操作和获取策略级联操作（Cascade）@Entitypublic class User &#123;        /**     * 级联操作类型：     * CascadeType.PERSIST: 保存用户时，自动保存关联的订单     * CascadeType.MERGE: 更新用户时，自动更新关联的订单     * CascadeType.REMOVE: 删除用户时，自动删除关联的订单     * CascadeType.REFRESH: 刷新用户时，自动刷新关联的订单     * CascadeType.DETACH: 分离用户时，自动分离关联的订单     * CascadeType.ALL: 包含所有上述操作     */        // 删除用户时不会删除订单（业务需要保留订单记录）    @OneToMany(mappedBy = &quot;user&quot;, cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;)    private List&lt;Order&gt; orders;        // 删除用户时会删除用户详情（因为详情没有独立存在的意义）    @OneToOne(cascade = CascadeType.ALL)    private UserProfile profile;        // 不会删除角色（角色是独立的实体，可能被其他用户使用）    @ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE&#125;)    private Set&lt;Role&gt; roles;&#125;

获取策略（Fetch）@Entitypublic class User &#123;        /**     * 获取策略：     * FetchType.LAZY（懒加载）: 需要时才从数据库加载     * FetchType.EAGER（急加载）: 立即从数据库加载     */        // 懒加载：获取用户时不立即加载订单列表，只有访问orders时才查询数据库    @OneToMany(mappedBy = &quot;user&quot;, fetch = FetchType.LAZY)    private List&lt;Order&gt; orders;        // 急加载：获取用户时立即加载用户详情    @OneToOne(fetch = FetchType.EAGER)    private UserProfile profile;        // 默认的获取策略：    // @OneToOne, @ManyToOne: 默认是EAGER    // @OneToMany, @ManyToMany: 默认是LAZY&#125;// 解决N+1查询问题的方法@Repositorypublic class UserRepository extends JpaRepository&lt;User, Long&gt; &#123;        // 使用JOIN FETCH避免N+1问题    @Query(&quot;SELECT u FROM User u JOIN FETCH u.orders WHERE u.id = :id&quot;)    Optional&lt;User&gt; findByIdWithOrders(@Param(&quot;id&quot;) Long id);        // 使用@EntityGraph    @EntityGraph(attributePaths = &#123;&quot;orders&quot;, &quot;profile&quot;&#125;)    @Query(&quot;SELECT u FROM User u WHERE u.id = :id&quot;)    Optional&lt;User&gt; findByIdWithOrdersAndProfile(@Param(&quot;id&quot;) Long id);&#125;

完整的JPA实体示例/** * 完整的JPA实体示例：电商系统的订单实体 */@Entity@Table(name = &quot;orders&quot;)@EntityListeners(AuditingEntityListener.class) // 启用审计功能public class Order &#123;        @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;        @Column(name = &quot;order_number&quot;, nullable = false, unique = true, length = 50)    private String orderNumber;        @Column(name = &quot;total_amount&quot;, nullable = false, precision = 10, scale = 2)    private BigDecimal totalAmount;        @Enumerated(EnumType.STRING)    @Column(name = &quot;status&quot;, nullable = false)    private OrderStatus status;        @ManyToOne(fetch = FetchType.LAZY)    @JoinColumn(name = &quot;user_id&quot;, nullable = false)    private User user;        @OneToMany(mappedBy = &quot;order&quot;, cascade = CascadeType.ALL, fetch = FetchType.LAZY)    private List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();        @Embedded    private Address shippingAddress;        // 审计字段    @CreatedDate    @Column(name = &quot;created_at&quot;, nullable = false, updatable = false)    private LocalDateTime createdAt;        @LastModifiedDate    @Column(name = &quot;updated_at&quot;)    private LocalDateTime updatedAt;        @CreatedBy    @Column(name = &quot;created_by&quot;, updatable = false)    private String createdBy;        @LastModifiedBy    @Column(name = &quot;updated_by&quot;)    private String updatedBy;        // 生命周期回调方法    @PrePersist    protected void onCreate() &#123;        if (orderNumber == null) &#123;            orderNumber = generateOrderNumber();        &#125;        if (status == null) &#123;            status = OrderStatus.PENDING;        &#125;    &#125;        @PreUpdate    protected void onUpdate() &#123;        // 更新前的逻辑    &#125;        private String generateOrderNumber() &#123;        return &quot;ORD&quot; + System.currentTimeMillis();    &#125;        // 便利方法    public void addOrderItem(OrderItem item) &#123;        orderItems.add(item);        item.setOrder(this);    &#125;        public void removeOrderItem(OrderItem item) &#123;        orderItems.remove(item);        item.setOrder(null);    &#125;        // 构造器、getter、setter...&#125;// 嵌入式值对象@Embeddablepublic class Address &#123;    @Column(name = &quot;street&quot;)    private String street;        @Column(name = &quot;city&quot;)    private String city;        @Column(name = &quot;state&quot;)    private String state;        @Column(name = &quot;zip_code&quot;)    private String zipCode;        @Column(name = &quot;country&quot;)    private String country;        // 构造器、getter、setter...&#125;// 枚举类型public enum OrderStatus &#123;    PENDING(&quot;待处理&quot;),    CONFIRMED(&quot;已确认&quot;),    SHIPPED(&quot;已发货&quot;),    DELIVERED(&quot;已送达&quot;),    CANCELLED(&quot;已取消&quot;);        private final String description;        OrderStatus(String description) &#123;        this.description = description;    &#125;        public String getDescription() &#123;        return description;    &#125;&#125;

6.4 Bean Validation（数据验证）注解详解Bean Validation是Java的数据验证标准，用于验证Java对象的字段值是否符合预期。Spring Boot默认集成了Hibernate Validator（Bean Validation的实现）。
基础验证注解空值检查注解/** * 数据验证注解示例：用户注册表单 */public class UserRegistrationDto &#123;        /**     * @NotNull: 值不能为null     * @NotEmpty: 值不能为null且长度大于0（用于字符串、集合、数组）     * @NotBlank: 值不能为null、空字符串或只包含空白字符（只用于字符串）     */        @NotNull(message = &quot;用户名不能为空&quot;)    @NotBlank(message = &quot;用户名不能为空白&quot;)    @Size(min = 3, max = 20, message = &quot;用户名长度必须在3-20个字符之间&quot;)    private String username;        @NotEmpty(message = &quot;密码不能为空&quot;)    @Size(min = 6, max = 50, message = &quot;密码长度必须在6-50个字符之间&quot;)    private String password;        @NotBlank(message = &quot;确认密码不能为空&quot;)    private String confirmPassword;        @NotNull(message = &quot;邮箱不能为空&quot;)    @NotBlank(message = &quot;邮箱不能为空白&quot;)    @Email(message = &quot;邮箱格式不正确&quot;)    private String email;        // 构造器、getter、setter...&#125;// 验证示例@RestController@RequestMapping(&quot;/api/auth&quot;)@Validated // 启用方法级别的验证public class AuthController &#123;        @PostMapping(&quot;/register&quot;)    public ResponseEntity&lt;String&gt; register(@Valid @RequestBody UserRegistrationDto dto) &#123;        // @Valid 会自动触发验证，如果验证失败会抛出MethodArgumentNotValidException                // 验证通过后的业务逻辑        userService.registerUser(dto);        return ResponseEntity.ok(&quot;注册成功&quot;);    &#125;        // 方法参数验证    @GetMapping(&quot;/check-username&quot;)    public ResponseEntity&lt;Boolean&gt; checkUsername(            @RequestParam @NotBlank @Size(min = 3, max = 20) String username) &#123;        boolean available = userService.isUsernameAvailable(username);        return ResponseEntity.ok(available);    &#125;&#125;

数值范围验证注解public class ProductDto &#123;        @NotBlank(message = &quot;商品名称不能为空&quot;)    @Size(max = 100, message = &quot;商品名称不能超过100个字符&quot;)    private String name;        /**     * 数值验证注解：     * @Min: 最小值     * @Max: 最大值     * @DecimalMin: 最小小数值     * @DecimalMax: 最大小数值     * @Positive: 正数（大于0）     * @PositiveOrZero: 正数或0     * @Negative: 负数（小于0）     * @NegativeOrZero: 负数或0     */        @NotNull(message = &quot;价格不能为空&quot;)    @DecimalMin(value = &quot;0.01&quot;, message = &quot;价格必须大于0.01&quot;)    @DecimalMax(value = &quot;999999.99&quot;, message = &quot;价格不能超过999999.99&quot;)    @Digits(integer = 6, fraction = 2, message = &quot;价格格式不正确，最多6位整数和2位小数&quot;)    private BigDecimal price;        @Min(value = 0, message = &quot;库存数量不能为负数&quot;)    @Max(value = 10000, message = &quot;库存数量不能超过10000&quot;)    private Integer stockQuantity;        @Positive(message = &quot;重量必须为正数&quot;)    private Double weight;        @PositiveOrZero(message = &quot;折扣不能为负数&quot;)    @DecimalMax(value = &quot;1.0&quot;, message = &quot;折扣不能超过1.0&quot;)    private BigDecimal discount;        // 构造器、getter、setter...&#125;

字符串格式验证注解public class ContactDto &#123;        /**     * 字符串格式验证注解：     * @Email: 邮箱格式     * @Pattern: 正则表达式匹配     * @Size: 字符串长度     */        @NotBlank(message = &quot;姓名不能为空&quot;)    @Size(min = 2, max = 50, message = &quot;姓名长度必须在2-50个字符之间&quot;)    @Pattern(regexp = &quot;^[\\u4e00-\\u9fa5a-zA-Z\\s]+$&quot;, message = &quot;姓名只能包含中文、英文字母和空格&quot;)    private String name;        @Email(message = &quot;邮箱格式不正确&quot;)    @NotBlank(message = &quot;邮箱不能为空&quot;)    private String email;        // 中国手机号验证    @Pattern(regexp = &quot;^1[3-9]\\d&#123;9&#125;$&quot;, message = &quot;手机号格式不正确&quot;)    @NotBlank(message = &quot;手机号不能为空&quot;)    private String phoneNumber;        // 身份证号验证    @Pattern(regexp = &quot;^[1-9]\\d&#123;5&#125;(18|19|20)\\d&#123;2&#125;((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d&#123;3&#125;[0-9Xx]$&quot;,              message = &quot;身份证号格式不正确&quot;)    private String idCard;        // URL验证    @Pattern(regexp = &quot;^https?://.+&quot;, message = &quot;网址格式不正确&quot;)    private String website;        // 邮政编码验证    @Pattern(regexp = &quot;^\\d&#123;6&#125;$&quot;, message = &quot;邮政编码必须是6位数字&quot;)    private String zipCode;        // 构造器、getter、setter...&#125;

时间日期验证注解public class EventDto &#123;        @NotBlank(message = &quot;活动名称不能为空&quot;)    private String name;        /**     * 时间验证注解：     * @Past: 过去的时间     * @PastOrPresent: 过去或现在的时间     * @Future: 未来的时间     * @FutureOrPresent: 未来或现在的时间     */        @NotNull(message = &quot;生日不能为空&quot;)    @Past(message = &quot;生日必须是过去的日期&quot;)    private LocalDate birthday;        @NotNull(message = &quot;开始时间不能为空&quot;)    @FutureOrPresent(message = &quot;开始时间不能早于当前时间&quot;)    private LocalDateTime startTime;        @NotNull(message = &quot;结束时间不能为空&quot;)    @Future(message = &quot;结束时间必须是未来的时间&quot;)    private LocalDateTime endTime;        @PastOrPresent(message = &quot;创建时间不能是未来时间&quot;)    private LocalDateTime createdAt;        // 构造器、getter、setter...&#125;

高级验证功能自定义验证注解/** * 自定义验证注解：密码强度验证 */@Target(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = PasswordValidator.class)@Documentedpublic @interface ValidPassword &#123;    String message() default &quot;密码强度不够：至少8位，包含大小写字母、数字和特殊字符&quot;;    Class&lt;?&gt;[] groups() default &#123;&#125;;    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;// 验证器实现public class PasswordValidator implements ConstraintValidator&lt;ValidPassword, String&gt; &#123;        private static final String PASSWORD_PATTERN =         &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;])[A-Za-z\\d@$!%*?&amp;]&#123;8,&#125;$&quot;;        private Pattern pattern;        @Override    public void initialize(ValidPassword constraintAnnotation) &#123;        pattern = Pattern.compile(PASSWORD_PATTERN);    &#125;        @Override    public boolean isValid(String password, ConstraintValidatorContext context) &#123;        if (password == null) &#123;            return false;        &#125;                Matcher matcher = pattern.matcher(password);        if (!matcher.matches()) &#123;            // 自定义错误消息            context.disableDefaultConstraintViolation();                        List&lt;String&gt; errors = new ArrayList&lt;&gt;();            if (password.length() &lt; 8) &#123;                errors.add(&quot;密码长度至少8位&quot;);            &#125;            if (!password.matches(&quot;.*[a-z].*&quot;)) &#123;                errors.add(&quot;必须包含小写字母&quot;);            &#125;            if (!password.matches(&quot;.*[A-Z].*&quot;)) &#123;                errors.add(&quot;必须包含大写字母&quot;);            &#125;            if (!password.matches(&quot;.*\\d.*&quot;)) &#123;                errors.add(&quot;必须包含数字&quot;);            &#125;            if (!password.matches(&quot;.*[@$!%*?&amp;].*&quot;)) &#123;                errors.add(&quot;必须包含特殊字符(@$!%*?&amp;)&quot;);            &#125;                        String errorMessage = &quot;密码要求：&quot; + String.join(&quot;、&quot;, errors);            context.buildConstraintViolationWithTemplate(errorMessage)                   .addConstraintViolation();                        return false;        &#125;                return true;    &#125;&#125;// 使用自定义验证注解public class ChangePasswordDto &#123;        @NotBlank(message = &quot;当前密码不能为空&quot;)    private String currentPassword;        @ValidPassword // 使用自定义验证注解    @NotBlank(message = &quot;新密码不能为空&quot;)    private String newPassword;        @NotBlank(message = &quot;确认密码不能为空&quot;)    private String confirmPassword;        // 构造器、getter、setter...&#125;

类级别验证（跨字段验证）/** * 类级别验证注解：确保两个字段相等 */@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = FieldMatchValidator.class)@Documentedpublic @interface FieldMatch &#123;    String message() default &quot;字段不匹配&quot;;    String first();    String second();    Class&lt;?&gt;[] groups() default &#123;&#125;;    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;// 验证器实现public class FieldMatchValidator implements ConstraintValidator&lt;FieldMatch, Object&gt; &#123;        private String firstFieldName;    private String secondFieldName;        @Override    public void initialize(FieldMatch constraintAnnotation) &#123;        firstFieldName = constraintAnnotation.first();        secondFieldName = constraintAnnotation.second();    &#125;        @Override    public boolean isValid(Object value, ConstraintValidatorContext context) &#123;        try &#123;            Object firstObj = getFieldValue(value, firstFieldName);            Object secondObj = getFieldValue(value, secondFieldName);                        boolean valid = Objects.equals(firstObj, secondObj);                        if (!valid) &#123;                context.disableDefaultConstraintViolation();                context.buildConstraintViolationWithTemplate(                    String.format(&quot;%s和%s必须相同&quot;, firstFieldName, secondFieldName))                       .addPropertyNode(secondFieldName)                       .addConstraintViolation();            &#125;                        return valid;        &#125; catch (Exception e) &#123;            return false;        &#125;    &#125;        private Object getFieldValue(Object object, String fieldName) throws Exception &#123;        Class&lt;?&gt; clazz = object.getClass();        Field field = clazz.getDeclaredField(fieldName);        field.setAccessible(true);        return field.get(object);    &#125;&#125;// 使用类级别验证@FieldMatch(first = &quot;password&quot;, second = &quot;confirmPassword&quot;, message = &quot;密码和确认密码必须相同&quot;)@FieldMatch(first = &quot;email&quot;, second = &quot;confirmEmail&quot;, message = &quot;邮箱和确认邮箱必须相同&quot;)public class UserRegistrationDto &#123;        @NotBlank(message = &quot;用户名不能为空&quot;)    @Size(min = 3, max = 20, message = &quot;用户名长度必须在3-20个字符之间&quot;)    private String username;        @ValidPassword    @NotBlank(message = &quot;密码不能为空&quot;)    private String password;        @NotBlank(message = &quot;确认密码不能为空&quot;)    private String confirmPassword;        @Email(message = &quot;邮箱格式不正确&quot;)    @NotBlank(message = &quot;邮箱不能为空&quot;)    private String email;        @NotBlank(message = &quot;确认邮箱不能为空&quot;)    private String confirmEmail;        // 构造器、getter、setter...&#125;

验证组（Validation Groups）/** * 验证组：在不同场景下应用不同的验证规则 */// 定义验证组接口public interface CreateGroup &#123;&#125;public interface UpdateGroup &#123;&#125;public class UserDto &#123;        // ID只在更新时需要    @NotNull(groups = UpdateGroup.class, message = &quot;更新时ID不能为空&quot;)    @Null(groups = CreateGroup.class, message = &quot;创建时ID必须为空&quot;)    private Long id;        // 用户名在创建和更新时都需要验证    @NotBlank(groups = &#123;CreateGroup.class, UpdateGroup.class&#125;, message = &quot;用户名不能为空&quot;)    @Size(min = 3, max = 20, groups = &#123;CreateGroup.class, UpdateGroup.class&#125;,           message = &quot;用户名长度必须在3-20个字符之间&quot;)    private String username;        // 密码只在创建时需要    @NotBlank(groups = CreateGroup.class, message = &quot;创建时密码不能为空&quot;)    @ValidPassword(groups = CreateGroup.class)    private String password;        // 邮箱在创建和更新时都需要验证    @Email(groups = &#123;CreateGroup.class, UpdateGroup.class&#125;, message = &quot;邮箱格式不正确&quot;)    @NotBlank(groups = &#123;CreateGroup.class, UpdateGroup.class&#125;, message = &quot;邮箱不能为空&quot;)    private String email;        // 构造器、getter、setter...&#125;// 在控制器中使用验证组@RestController@RequestMapping(&quot;/api/users&quot;)public class UserController &#123;        @PostMapping    public ResponseEntity&lt;User&gt; createUser(@Validated(CreateGroup.class) @RequestBody UserDto dto) &#123;        // 只验证CreateGroup组的注解        User user = userService.createUser(dto);        return ResponseEntity.status(HttpStatus.CREATED).body(user);    &#125;        @PutMapping(&quot;/&#123;id&#125;&quot;)    public ResponseEntity&lt;User&gt; updateUser(@PathVariable Long id,                                          @Validated(UpdateGroup.class) @RequestBody UserDto dto) &#123;        // 只验证UpdateGroup组的注解        dto.setId(id);        User user = userService.updateUser(dto);        return ResponseEntity.ok(user);    &#125;&#125;

全局异常处理/** * 全局异常处理：统一处理验证错误 */@RestControllerAdvicepublic class GlobalExceptionHandler &#123;        /**     * 处理@Valid验证失败的异常（请求体验证）     */    @ExceptionHandler(MethodArgumentNotValidException.class)    public ResponseEntity&lt;ValidationErrorResponse&gt; handleValidationException(            MethodArgumentNotValidException ex) &#123;                ValidationErrorResponse errorResponse = new ValidationErrorResponse();        errorResponse.setMessage(&quot;请求参数验证失败&quot;);        errorResponse.setTimestamp(LocalDateTime.now());                // 收集所有验证错误        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();        ex.getBindingResult().getFieldErrors().forEach(error -&gt; &#123;            errors.put(error.getField(), error.getDefaultMessage());        &#125;);                // 收集类级别验证错误        ex.getBindingResult().getGlobalErrors().forEach(error -&gt; &#123;            errors.put(error.getObjectName(), error.getDefaultMessage());        &#125;);                errorResponse.setErrors(errors);                return ResponseEntity.badRequest().body(errorResponse);    &#125;        /**     * 处理@Validated验证失败的异常（方法参数验证）     */    @ExceptionHandler(ConstraintViolationException.class)    public ResponseEntity&lt;ValidationErrorResponse&gt; handleConstraintViolationException(            ConstraintViolationException ex) &#123;                ValidationErrorResponse errorResponse = new ValidationErrorResponse();        errorResponse.setMessage(&quot;参数验证失败&quot;);        errorResponse.setTimestamp(LocalDateTime.now());                Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();        ex.getConstraintViolations().forEach(violation -&gt; &#123;            String propertyPath = violation.getPropertyPath().toString();            String message = violation.getMessage();            errors.put(propertyPath, message);        &#125;);                errorResponse.setErrors(errors);                return ResponseEntity.badRequest().body(errorResponse);    &#125;&#125;// 验证错误响应类@Datapublic class ValidationErrorResponse &#123;    private String message;    private LocalDateTime timestamp;    private Map&lt;String, String&gt; errors;&#125;

6.5 测试注解详解（JUnit 5 + Spring Boot Test）JUnit 5是Java的标准测试框架，Spring Boot Test提供了Spring应用的测试支持。
JUnit 5 核心注解基础测试注解/** * JUnit 5 基础测试示例 */class CalculatorTest &#123;        private Calculator calculator;        /**     * @BeforeAll: 在所有测试方法之前执行一次（必须是static方法）     * 用途：初始化昂贵的资源，如数据库连接池、文件读取等     */    @BeforeAll    static void setUpClass() &#123;        System.out.println(&quot;初始化测试类资源&quot;);        // 例如：初始化数据库连接池        // DatabasePool.initialize();    &#125;        /**     * @AfterAll: 在所有测试方法之后执行一次（必须是static方法）     * 用途：清理昂贵的资源     */    @AfterAll    static void tearDownClass() &#123;        System.out.println(&quot;清理测试类资源&quot;);        // 例如：关闭数据库连接池        // DatabasePool.close();    &#125;        /**     * @BeforeEach: 在每个测试方法之前执行     * 用途：为每个测试创建干净的环境     */    @BeforeEach    void setUp() &#123;        calculator = new Calculator();        System.out.println(&quot;为测试方法准备Calculator实例&quot;);    &#125;        /**     * @AfterEach: 在每个测试方法之后执行     * 用途：清理每个测试产生的副作用     */    @AfterEach    void tearDown() &#123;        calculator = null;        System.out.println(&quot;清理Calculator实例&quot;);    &#125;        /**     * @Test: 标记这是一个测试方法     * @DisplayName: 为测试提供可读的名称（在测试报告中显示）     */    @Test    @DisplayName(&quot;测试两个正数相加&quot;)    void testAddPositiveNumbers() &#123;        // Given（准备）        int a = 5;        int b = 3;        int expected = 8;                // When（执行）        int actual = calculator.add(a, b);                // Then（验证）        assertEquals(expected, actual, &quot;5 + 3 应该等于 8&quot;);    &#125;        @Test    @DisplayName(&quot;测试除法操作&quot;)    void testDivision() &#123;        assertEquals(2.0, calculator.divide(10, 5), 0.001, &quot;10 / 5 应该等于 2.0&quot;);    &#125;        /**     * @Test注解的异常测试     */    @Test    @DisplayName(&quot;测试除零异常&quot;)    void testDivisionByZero() &#123;        // 验证是否抛出预期的异常        ArithmeticException exception = assertThrows(            ArithmeticException.class,             () -&gt; calculator.divide(10, 0),            &quot;除零应该抛出ArithmeticException&quot;        );                // 验证异常消息        assertEquals(&quot;/ by zero&quot;, exception.getMessage());    &#125;        /**     * @Disabled: 禁用测试（类似于JUnit 4的@Ignore）     */    @Test    @Disabled(&quot;暂时禁用，等待修复bug #123&quot;)    void testComplexCalculation() &#123;        // 这个测试不会执行    &#125;&#125;

参数化测试注解/** * 参数化测试：使用不同的参数运行同一个测试 */class ParameterizedTestExample &#123;        /**     * @ParameterizedTest: 参数化测试     * @ValueSource: 提供简单类型的参数值     */    @ParameterizedTest    @DisplayName(&quot;测试字符串长度验证&quot;)    @ValueSource(strings = &#123;&quot;&quot;, &quot;   &quot;, &quot;test&quot;, &quot;hello world&quot;&#125;)    void testStringLength(String input) &#123;        if (input.trim().isEmpty()) &#123;            assertTrue(input.trim().length() == 0);        &#125; else &#123;            assertTrue(input.length() &gt; 0);        &#125;    &#125;        @ParameterizedTest    @DisplayName(&quot;测试数字是否为偶数&quot;)    @ValueSource(ints = &#123;2, 4, 6, 8, 10&#125;)    void testEvenNumbers(int number) &#123;        assertTrue(number % 2 == 0, number + &quot; 应该是偶数&quot;);    &#125;        /**     * @CsvSource: 提供CSV格式的参数     */    @ParameterizedTest    @DisplayName(&quot;测试加法运算&quot;)    @CsvSource(&#123;        &quot;1, 2, 3&quot;,        &quot;5, 7, 12&quot;,         &quot;-2, 3, 1&quot;,        &quot;0, 0, 0&quot;    &#125;)    void testAddition(int a, int b, int expected) &#123;        Calculator calculator = new Calculator();        assertEquals(expected, calculator.add(a, b));    &#125;        /**     * @CsvFileSource: 从CSV文件读取参数     */    @ParameterizedTest    @DisplayName(&quot;从文件测试用户数据&quot;)    @CsvFileSource(resources = &quot;/test-users.csv&quot;, numLinesToSkip = 1)    void testUserValidation(String username, String email, boolean expectedValid) &#123;        User user = new User(username, email);        assertEquals(expectedValid, UserValidator.isValid(user));    &#125;        /**     * @MethodSource: 使用方法提供参数     */    @ParameterizedTest    @DisplayName(&quot;测试密码强度&quot;)    @MethodSource(&quot;providePasswordTestCases&quot;)    void testPasswordStrength(String password, boolean expectedStrong) &#123;        assertEquals(expectedStrong, PasswordValidator.isStrong(password));    &#125;        // 提供测试参数的静态方法    static Stream&lt;Arguments&gt; providePasswordTestCases() &#123;        return Stream.of(            Arguments.of(&quot;123456&quot;, false),            Arguments.of(&quot;Password123!&quot;, true),            Arguments.of(&quot;weakpass&quot;, false),            Arguments.of(&quot;Strong@Pass123&quot;, true)        );    &#125;        /**     * @EnumSource: 使用枚举值作为参数     */    @ParameterizedTest    @DisplayName(&quot;测试用户状态&quot;)    @EnumSource(UserStatus.class)    void testUserStatus(UserStatus status) &#123;        assertNotNull(status);        assertNotNull(status.getDescription());    &#125;        /**     * @ArgumentsSource: 使用自定义参数提供者     */    @ParameterizedTest    @DisplayName(&quot;测试自定义参数&quot;)    @ArgumentsSource(CustomArgumentsProvider.class)    void testWithCustomProvider(String input, int expectedLength) &#123;        assertEquals(expectedLength, input.length());    &#125;&#125;// 自定义参数提供者class CustomArgumentsProvider implements ArgumentsProvider &#123;    @Override    public Stream&lt;? extends Arguments&gt; provideArguments(ExtensionContext context) &#123;        return Stream.of(            Arguments.of(&quot;hello&quot;, 5),            Arguments.of(&quot;world&quot;, 5),            Arguments.of(&quot;test&quot;, 4)        );    &#125;&#125;

Spring Boot 测试注解完整应用上下文测试/** * @SpringBootTest: 加载完整的Spring应用上下文 * 用途：集成测试，测试整个应用的交互 */@SpringBootTest(    webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, // 随机端口启动Web服务器    properties = &#123;&quot;spring.profiles.active=test&quot;&#125; // 激活test配置文件)@TestPropertySource(locations = &quot;classpath:application-test.properties&quot;) // 额外的测试配置@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD) // 每个测试后重建上下文class UserServiceIntegrationTest &#123;        @Autowired    private UserService userService;        @Autowired    private UserRepository userRepository;        @Autowired    private TestRestTemplate restTemplate; // 用于HTTP请求测试        @LocalServerPort    private int port; // 获取随机分配的端口号        @Test    @DisplayName(&quot;集成测试：创建用户的完整流程&quot;)    void testCreateUserIntegration() &#123;        // Given        String username = &quot;testuser&quot;;        String email = &quot;test@example.com&quot;;                // When        User user = userService.createUser(username, email);                // Then        assertNotNull(user.getId());        assertEquals(username, user.getUsername());        assertEquals(email, user.getEmail());                // 验证数据确实保存到数据库        Optional&lt;User&gt; savedUser = userRepository.findById(user.getId());        assertTrue(savedUser.isPresent());        assertEquals(username, savedUser.get().getUsername());    &#125;        @Test    @DisplayName(&quot;HTTP接口集成测试&quot;)    void testUserApiEndpoint() &#123;        // Given        CreateUserRequest request = new CreateUserRequest(&quot;apiuser&quot;, &quot;api@example.com&quot;);                // When        ResponseEntity&lt;User&gt; response = restTemplate.postForEntity(            &quot;http://localhost:&quot; + port + &quot;/api/users&quot;,            request,            User.class        );                // Then        assertEquals(HttpStatus.CREATED, response.getStatusCode());        assertNotNull(response.getBody());        assertEquals(&quot;apiuser&quot;, response.getBody().getUsername());    &#125;&#125;

Web层测试/** * @WebMvcTest: 只加载Web层组件（Controller、Filter、WebMvcConfigurer等） * 优点：启动速度快，只测试Web层逻辑 */@WebMvcTest(UserController.class) // 只加载UserControllerclass UserControllerTest &#123;        @Autowired    private MockMvc mockMvc; // 模拟HTTP请求        @MockBean    private UserService userService; // 模拟Service层        @Autowired    private ObjectMapper objectMapper; // JSON序列化工具        @Test    @DisplayName(&quot;测试获取用户API - 成功案例&quot;)    void testGetUser_Success() throws Exception &#123;        // Given        Long userId = 1L;        User mockUser = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);        mockUser.setId(userId);                when(userService.findById(userId)).thenReturn(mockUser);                // When &amp; Then        mockMvc.perform(get(&quot;/api/users/&#123;id&#125;&quot;, userId)                .contentType(MediaType.APPLICATION_JSON))                .andExpect(status().isOk())                .andExpect(jsonPath(&quot;$.id&quot;).value(userId))                .andExpect(jsonPath(&quot;$.username&quot;).value(&quot;testuser&quot;))                .andExpect(jsonPath(&quot;$.email&quot;).value(&quot;test@example.com&quot;))                .andDo(print()); // 打印请求和响应详情                // 验证Service方法被调用        verify(userService, times(1)).findById(userId);    &#125;        @Test    @DisplayName(&quot;测试获取用户API - 用户不存在&quot;)    void testGetUser_NotFound() throws Exception &#123;        // Given        Long userId = 999L;        when(userService.findById(userId)).thenThrow(new UserNotFoundException(&quot;用户不存在&quot;));                // When &amp; Then        mockMvc.perform(get(&quot;/api/users/&#123;id&#125;&quot;, userId)                .contentType(MediaType.APPLICATION_JSON))                .andExpect(status().isNotFound());                verify(userService, times(1)).findById(userId);    &#125;        @Test    @DisplayName(&quot;测试创建用户API - 成功案例&quot;)    void testCreateUser_Success() throws Exception &#123;        // Given        CreateUserRequest request = new CreateUserRequest(&quot;newuser&quot;, &quot;new@example.com&quot;);        User createdUser = new User(&quot;newuser&quot;, &quot;new@example.com&quot;);        createdUser.setId(1L);                when(userService.createUser(anyString(), anyString())).thenReturn(createdUser);                // When &amp; Then        mockMvc.perform(post(&quot;/api/users&quot;)                .contentType(MediaType.APPLICATION_JSON)                .content(objectMapper.writeValueAsString(request)))                .andExpect(status().isCreated())                .andExpect(jsonPath(&quot;$.id&quot;).exists())                .andExpect(jsonPath(&quot;$.username&quot;).value(&quot;newuser&quot;))                .andExpect(jsonPath(&quot;$.email&quot;).value(&quot;new@example.com&quot;));                verify(userService, times(1)).createUser(&quot;newuser&quot;, &quot;new@example.com&quot;);    &#125;        @Test    @DisplayName(&quot;测试创建用户API - 验证失败&quot;)    void testCreateUser_ValidationError() throws Exception &#123;        // Given: 无效的请求数据        CreateUserRequest request = new CreateUserRequest(&quot;&quot;, &quot;invalid-email&quot;);                // When &amp; Then        mockMvc.perform(post(&quot;/api/users&quot;)                .contentType(MediaType.APPLICATION_JSON)                .content(objectMapper.writeValueAsString(request)))                .andExpect(status().isBadRequest())                .andExpect(jsonPath(&quot;$.errors&quot;).exists())                .andExpect(jsonPath(&quot;$.errors.username&quot;).exists())                .andExpect(jsonPath(&quot;$.errors.email&quot;).exists());                // 验证Service方法没有被调用        verify(userService, never()).createUser(anyString(), anyString());    &#125;&#125;

数据层测试/** * @DataJpaTest: 只加载JPA相关组件 * 特点：使用内存数据库，事务自动回滚 */@DataJpaTestclass UserRepositoryTest &#123;        @Autowired    private TestEntityManager entityManager; // 用于测试的EntityManager        @Autowired    private UserRepository userRepository;        @Test    @DisplayName(&quot;测试根据用户名查找用户&quot;)    void testFindByUsername() &#123;        // Given        User user = new User(&quot;testuser&quot;, &quot;test@example.com&quot;);        entityManager.persistAndFlush(user); // 立即保存到数据库                // When        Optional&lt;User&gt; found = userRepository.findByUsername(&quot;testuser&quot;);                // Then        assertTrue(found.isPresent());        assertEquals(&quot;testuser&quot;, found.get().getUsername());        assertEquals(&quot;test@example.com&quot;, found.get().getEmail());    &#125;        @Test    @DisplayName(&quot;测试根据邮箱查找用户&quot;)    void testFindByEmail() &#123;        // Given        User user1 = new User(&quot;user1&quot;, &quot;user1@example.com&quot;);        User user2 = new User(&quot;user2&quot;, &quot;user2@example.com&quot;);        entityManager.persist(user1);        entityManager.persist(user2);        entityManager.flush();                // When        Optional&lt;User&gt; found = userRepository.findByEmail(&quot;user1@example.com&quot;);                // Then        assertTrue(found.isPresent());        assertEquals(&quot;user1&quot;, found.get().getUsername());    &#125;        @Test    @DisplayName(&quot;测试用户名是否存在&quot;)    void testExistsByUsername() &#123;        // Given        User user = new User(&quot;existinguser&quot;, &quot;existing@example.com&quot;);        entityManager.persistAndFlush(user);                // When &amp; Then        assertTrue(userRepository.existsByUsername(&quot;existinguser&quot;));        assertFalse(userRepository.existsByUsername(&quot;nonexistentuser&quot;));    &#125;        @Test    @DisplayName(&quot;测试自定义查询方法&quot;)    void testFindActiveUsers() &#123;        // Given        User activeUser = new User(&quot;activeuser&quot;, &quot;active@example.com&quot;);        activeUser.setStatus(UserStatus.ACTIVE);                User inactiveUser = new User(&quot;inactiveuser&quot;, &quot;inactive@example.com&quot;);        inactiveUser.setStatus(UserStatus.INACTIVE);                entityManager.persist(activeUser);        entityManager.persist(inactiveUser);        entityManager.flush();                // When        List&lt;User&gt; activeUsers = userRepository.findByStatus(UserStatus.ACTIVE);                // Then        assertEquals(1, activeUsers.size());        assertEquals(&quot;activeuser&quot;, activeUsers.get(0).getUsername());    &#125;&#125;

服务层测试（使用Mock）/** * 纯单元测试：不加载Spring上下文，使用Mock对象 */@ExtendWith(MockitoExtension.class) // JUnit 5 + Mockitoclass UserServiceTest &#123;        @Mock    private UserRepository userRepository; // Mock的Repository        @Mock    private EmailService emailService; // Mock的邮件服务        @Mock    private PasswordEncoder passwordEncoder; // Mock的密码编码器        @InjectMocks    private UserService userService; // 被测试的服务（自动注入Mock对象）        @Test    @DisplayName(&quot;测试创建用户 - 成功案例&quot;)    void testCreateUser_Success() &#123;        // Given        String username = &quot;newuser&quot;;        String email = &quot;new@example.com&quot;;        String rawPassword = &quot;password123&quot;;        String encodedPassword = &quot;encoded_password&quot;;                User savedUser = new User(username, email);        savedUser.setId(1L);        savedUser.setPassword(encodedPassword);                // Mock行为设置        when(userRepository.existsByUsername(username)).thenReturn(false);        when(userRepository.existsByEmail(email)).thenReturn(false);        when(passwordEncoder.encode(rawPassword)).thenReturn(encodedPassword);        when(userRepository.save(any(User.class))).thenReturn(savedUser);                // When        User result = userService.createUser(username, email, rawPassword);                // Then        assertNotNull(result);        assertEquals(1L, result.getId());        assertEquals(username, result.getUsername());        assertEquals(email, result.getEmail());        assertEquals(encodedPassword, result.getPassword());                // 验证Mock对象的调用        verify(userRepository, times(1)).existsByUsername(username);        verify(userRepository, times(1)).existsByEmail(email);        verify(passwordEncoder, times(1)).encode(rawPassword);        verify(userRepository, times(1)).save(any(User.class));        verify(emailService, times(1)).sendWelcomeEmail(email, username);    &#125;        @Test    @DisplayName(&quot;测试创建用户 - 用户名已存在&quot;)    void testCreateUser_UsernameExists() &#123;        // Given        String username = &quot;existinguser&quot;;        String email = &quot;new@example.com&quot;;                when(userRepository.existsByUsername(username)).thenReturn(true);                // When &amp; Then        DuplicateUsernameException exception = assertThrows(            DuplicateUsernameException.class,            () -&gt; userService.createUser(username, email, &quot;password&quot;)        );                assertEquals(&quot;用户名已存在: &quot; + username, exception.getMessage());                // 验证后续方法没有被调用        verify(userRepository, times(1)).existsByUsername(username);        verify(userRepository, never()).existsByEmail(anyString());        verify(userRepository, never()).save(any(User.class));        verify(emailService, never()).sendWelcomeEmail(anyString(), anyString());    &#125;        @Test    @DisplayName(&quot;测试用户登录 - 成功案例&quot;)    void testAuthenticate_Success() &#123;        // Given        String username = &quot;testuser&quot;;        String rawPassword = &quot;password123&quot;;        String encodedPassword = &quot;encoded_password&quot;;                User user = new User(username, &quot;test@example.com&quot;);        user.setPassword(encodedPassword);        user.setStatus(UserStatus.ACTIVE);                when(userRepository.findByUsername(username)).thenReturn(Optional.of(user));        when(passwordEncoder.matches(rawPassword, encodedPassword)).thenReturn(true);                // When        boolean result = userService.authenticate(username, rawPassword);                // Then        assertTrue(result);                verify(userRepository, times(1)).findByUsername(username);        verify(passwordEncoder, times(1)).matches(rawPassword, encodedPassword);    &#125;        @Test    @DisplayName(&quot;测试用户登录 - 密码错误&quot;)    void testAuthenticate_WrongPassword() &#123;        // Given        String username = &quot;testuser&quot;;        String rawPassword = &quot;wrongpassword&quot;;        String encodedPassword = &quot;encoded_password&quot;;                User user = new User(username, &quot;test@example.com&quot;);        user.setPassword(encodedPassword);                when(userRepository.findByUsername(username)).thenReturn(Optional.of(user));        when(passwordEncoder.matches(rawPassword, encodedPassword)).thenReturn(false);                // When        boolean result = userService.authenticate(username, rawPassword);                // Then        assertFalse(result);                verify(userRepository, times(1)).findByUsername(username);        verify(passwordEncoder, times(1)).matches(rawPassword, encodedPassword);    &#125;&#125;

7. 自定义注解7.1 创建自定义注解// 定义注解@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface LogExecutionTime &#123;    String value() default &quot;&quot;;    boolean enabled() default true;&#125;// 使用注解public class BusinessService &#123;        @LogExecutionTime(&quot;用户查询&quot;)    public User findUser(Long id) &#123;        // 业务逻辑        return userRepository.findById(id);    &#125;        @LogExecutionTime(value = &quot;数据处理&quot;, enabled = false)    public void processData() &#123;        // 处理逻辑    &#125;&#125;

7.2 注解处理器实现@Component@Aspectpublic class LogExecutionTimeAspect &#123;        private static final Logger logger = LoggerFactory.getLogger(LogExecutionTimeAspect.class);        @Around(&quot;@annotation(logExecutionTime)&quot;)    public Object logExecutionTime(ProceedingJoinPoint joinPoint,                                   LogExecutionTime logExecutionTime) throws Throwable &#123;                if (!logExecutionTime.enabled()) &#123;            return joinPoint.proceed();        &#125;                long startTime = System.currentTimeMillis();        String operation = logExecutionTime.value().isEmpty() ?                           joinPoint.getSignature().getName() :                           logExecutionTime.value();                try &#123;            Object result = joinPoint.proceed();            long endTime = System.currentTimeMillis();            logger.info(&quot;操作 [&#123;&#125;] 执行时间: &#123;&#125;ms&quot;, operation, endTime - startTime);            return result;        &#125; catch (Exception e) &#123;            logger.error(&quot;操作 [&#123;&#125;] 执行失败&quot;, operation, e);            throw e;        &#125;    &#125;&#125;

7.3 通过反射处理注解public class AnnotationProcessor &#123;        public static void processAnnotations(Object obj) &#123;        Class&lt;?&gt; clazz = obj.getClass();                // 处理类级别注解        if (clazz.isAnnotationPresent(Component.class)) &#123;            Component component = clazz.getAnnotation(Component.class);            System.out.println(&quot;组件名称: &quot; + component.value());        &#125;                // 处理方法级别注解        Method[] methods = clazz.getDeclaredMethods();        for (Method method : methods) &#123;            if (method.isAnnotationPresent(LogExecutionTime.class)) &#123;                LogExecutionTime annotation = method.getAnnotation(LogExecutionTime.class);                System.out.println(&quot;方法 &quot; + method.getName() +                                  &quot; 需要记录执行时间: &quot; + annotation.value());            &#125;        &#125;                // 处理字段级别注解        Field[] fields = clazz.getDeclaredFields();        for (Field field : fields) &#123;            if (field.isAnnotationPresent(Autowired.class)) &#123;                System.out.println(&quot;字段 &quot; + field.getName() + &quot; 需要自动注入&quot;);            &#125;        &#125;    &#125;&#125;

8. 注解的最佳实践8.1 设计原则
单一职责：每个注解只做一件事
命名清晰：注解名称应该清楚表达其用途
参数合理：提供合理的默认值，减少使用复杂度
文档完善：为注解和参数提供详细文档

8.2 使用建议// ❌ 不好的设计 - 职责不清@AllInOne(log = true, validate = true, cache = true, retry = 3)public void method() &#123;&#125;// ✅ 好的设计 - 职责分离@Log@Validate@Cacheable@Retry(times = 3)public void method() &#123;&#125;

8.3 性能考虑// 反射操作应该缓存public class AnnotationCache &#123;    private static final Map&lt;Class&lt;?&gt;, List&lt;Method&gt;&gt; methodCache = new ConcurrentHashMap&lt;&gt;();        public static List&lt;Method&gt; getAnnotatedMethods(Class&lt;?&gt; clazz, Class&lt;? extends Annotation&gt; annotation) &#123;        return methodCache.computeIfAbsent(clazz, k -&gt; &#123;            return Arrays.stream(k.getDeclaredMethods())                        .filter(m -&gt; m.isAnnotationPresent(annotation))                        .collect(Collectors.toList());        &#125;);    &#125;&#125;

9. 常见错误和解决方案9.1 注解丢失问题// 问题：运行时无法获取注解@Target(ElementType.METHOD)// @Retention(RetentionPolicy.RUNTIME)  // 忘记添加public @interface MyAnnotation &#123;&#125;// 解决：正确设置保留策略@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation &#123;&#125;

9.2 继承问题// 问题：子类无法继承父类的注解@Inherited  // 添加此注解使得注解可以被继承@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Service &#123;&#125;

9.3 重复注解// Java 8+ 支持重复注解@Repeatable(Schedules.class)public @interface Schedule &#123;    String time();&#125;public @interface Schedules &#123;    Schedule[] value();&#125;// 使用@Schedule(time = &quot;morning&quot;)@Schedule(time = &quot;evening&quot;)public void task() &#123;&#125;

10. 学习建议10.1 循序渐进
理解基础：先掌握内置注解的使用
框架应用：学习Spring等框架中注解的使用
自定义注解：尝试创建自己的注解
深入原理：了解注解处理器和反射机制

10.2 实践项目
创建一个简单的Web项目，使用Spring Boot注解
实现一个日志记录的自定义注解
编写一个数据验证的注解系统

10.3 进阶学习
学习APT（Annotation Processing Tool）
了解编译时代码生成
研究主流框架的注解实现原理

总结Java注解是一个强大的元编程工具，它让代码更加简洁、可读性更强。相比C++的宏系统，Java注解提供了更安全、更强大的元数据机制。掌握注解的使用不仅能让你更好地使用现有框架，还能帮你设计出更优雅的API。
注解是对代码的描述，而不是代码本身。正确理解和使用注解，将大大提升Java编程水平。

感谢阅读！如果这篇文章对你有帮助，欢迎点赞和分享。
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>csnet 期末周复习</title>
    <url>/2025/08/12/csnet%20%E6%9C%9F%E6%9C%AB%E5%91%A8%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[📝 csnet 期末周复习
期末周复习自用，站建好了上传一下

计算机网络复习1.五层协议栈及其作用：

物理层（Physical Layer）：负责比特流的传输，定义硬件设备的电气、机械、过程和功能规范。
数据链路层（Data Link Layer）：负责在物理链路上可靠地传输数据帧，进行差错检测与纠正。
网络层（Network Layer）：负责数据包从源到目的地的路由选择和转发，实现不同网络之间的互联。
传输层（Transport Layer）：为两台主机上的进程之间提供端到端的可靠或不可靠的数据传输服务。
应用层（Application Layer）：为用户的应用进程提供网络服务，如HTTP、FTP、SMTP等。

2.ISO七层模型及其作用：

物理层（Physical Layer）：负责比特流的传输，定义物理设备的电气、机械、过程和功能规范。
数据链路层（Data Link Layer）：负责在物理链路上可靠地传输数据帧，进行差错检测与纠正。
网络层（Network Layer）：负责数据包的路由选择和转发，实现不同网络之间的互联。
传输层（Transport Layer）：为主机间进程提供端到端的可靠或不可靠的数据传输服务。
会话层（Session Layer）：管理会话，建立、管理和终止进程间的会话。
表示层（Presentation Layer）：处理数据的表示、加密、解密和压缩，保证数据能被应用层正确识别。
应用层（Application Layer）：为用户的应用进程提供网络服务，如HTTP、FTP、SMTP等。

3.七层与五层协议的对应关系：

物理层、数据链路层、网络层、传输层、应用层：在五层协议中与OSI模型的同名层直接对应。
OSI的会话层和表示层的功能，在五层协议中被合并到应用层中。


交换机与路由器（路由表）的功能比较：


交换机（Switch）：主要工作在数据链路层（第二层），根据MAC地址转发数据帧，通过维护MAC地址表实现局域网内的数据转发。
路由器（Router）：主要工作在网络层（第三层），根据IP地址转发数据包，通过维护路由表实现不同网络之间的数据转发。
相同点：二者都实现了数据的转发和路径选择。
不同点：交换机基于MAC地址、工作在二层，作用于局域网；路由器基于IP地址、工作在三层，作用于不同网络之间。


TCP流量控制与窗口机制：

(1) TCP接收方RecvBuffer、LastByteRead、LastByteRecv，发送方LastByteSent、LastByteAck，这些参数需满足什么关系？

接收方：LastByteRead &lt; LastByteRecv ≤ RecvBuffer
发送方：LastByteAck &lt; LastByteSent

(2) 发送方怎么知道rwnd大小，rwnd&#x3D;0时会发生什么，TCP如何解决？

发送方通过ACK报文中的窗口字段获知rwnd。
rwnd&#x3D;0时，发送方不能再发送数据，进入零窗口状态。
发送方会周期性发送窗口探测报文（Zero Window Probe）以探测窗口是否打开。

(3) 这个问题涉及到TCP的什么功能？有何作用？

涉及TCP的流量控制功能。
作用：防止发送方发送过快导致接收方缓存溢出，保证数据可靠传输。

(4) 有协议规定太小的报文不发，等所有报文都收到ack后再一起发小报文，这样做的目的和负面影响？

目的：减少小报文数量，降低网络开销，提高带宽利用率。
负面影响：增加时延，降低实时性，应用层等待时间变长。


拥塞控制总结：

(1) 拥塞控制的四个阶段：

慢启动（Slow Start）：CWND（拥塞窗口）以指数方式增长，直到达到ssthresh（慢启动阈值）。
拥塞避免（Congestion Avoidance）：CWND以线性方式增长，每收到一个ACK，CWND增加1&#x2F;CWND。
快速重传（Fast Retransmit）：收到3个冗余ACK时，立即重传丢失的数据包。
快速恢复（Fast Recovery）：ssthresh设置为当前CWND的一半，CWND调整为ssthresh+3，进入拥塞避免。

(2) 拥塞窗口CWND和ssthresh的变化：

慢启动阶段CWND指数增长，达到ssthresh后进入拥塞避免。
拥塞避免阶段CWND线性增长。
丢包（超时或3个冗余ACK）时，ssthresh&#x3D;当前CWND&#x2F;2，CWND重置（超时为1，3冗余ACK为ssthresh+3）。

(3) 拥塞控制事件：

丢包事件（如第16&#x2F;22 RTT）：CWND骤降，ssthresh调整。
快速恢复后CWND和ssthresh的变化：CWND&#x3D;ssthresh+3，ssthresh&#x3D;原CWND&#x2F;2。

(4) TCP-BIC（Binary Increase Congestion control）：

拥塞窗口采用二分法快速探测带宽上限，窗口收缩后以二分搜索方式快速恢复。
优势：带宽利用率高，收敛速度快，适合高带宽高延迟网络，避免了TCP-Reno线性增长慢、带宽利用率低的问题。
机制：丢包后窗口收缩到Wmin，然后以二分法探测Wmax，窗口增长更快且更平滑。


距离向量（DV）算法与毒性逆转：

(1) 距离向量（Distance Vector, DV）算法：

每个路由器维护一张到所有目的网络的距离向量表（即到每个目的地的最短距离和下一跳）。
路由器定期将自己的距离向量表发送给相邻的路由器。
路由器收到邻居的距离向量后，利用Bellman-Ford算法更新自己的路由表。
路由器只知道与自己直接相连的邻居信息，不知道全网的拓扑结构。
典型协议：RIP（Routing Information Protocol）就是基于DV算法的。
优点：实现简单，适合小型网络。
缺点：收敛慢，容易出现“路由环路”和“计数到无穷”等问题。

(2) 毒性逆转（Poison Reverse）：

是DV算法中为防止路由环路和“计数到无穷”问题而采用的一种机制。
当路由器A通过路由器B到达某个目的网络时，A会向B声明该目的网络的距离为“无穷大”（通常用16表示），即“毒性”信息。
这样B就不会再把到该目的网络的路由信息传回A，避免了环路和错误信息的传播。
毒性逆转能加快错误路由的收敛速度，但不能完全消除所有环路问题。


IGP、EGP、BGP详解：

(1) IGP（Interior Gateway Protocol，内部网关协议）：

IGP是指在同一个自治系统（AS）内部使用的路由协议，主要用于AS内部各路由器之间的路由信息交换和最优路径选择。
常见的IGP协议有：
RIP（Routing Information Protocol）：基于距离向量算法，适合小型网络，收敛慢。
OSPF（Open Shortest Path First）：基于链路状态算法，支持大规模网络，收敛快，广泛应用于企业和运营商网络。
IS-IS（Intermediate System to Intermediate System）：与OSPF类似，基于链路状态，常用于大型ISP和运营商网络。


IGP的特点是：只在AS内部传播路由信息，不负责AS之间的路由。

(2) EGP（Exterior Gateway Protocol，外部网关协议）：

EGP是指用于不同自治系统（AS）之间的路由选择和信息交换的协议。
早期的EGP协议是EGP（Exterior Gateway Protocol），但已被BGP取代。
目前实际应用中，唯一广泛使用的EGP协议是BGP（边界网关协议）。
EGP的作用是实现互联网范围的路由可达性，负责AS之间的路由传播和策略控制。

(3) BGP（Border Gateway Protocol，边界网关协议）：

BGP是目前互联网中唯一广泛使用的EGP协议，属于路径向量路由协议。
主要用于不同AS之间的路由信息交换，是互联网的“主干”协议。
BGP通过维护AS路径（AS Path）等属性，实现路由选择和环路避免。
支持路由策略控制，可以根据运营商、业务需求等灵活选择路由。
BGP分为eBGP（外部BGP，用于AS之间）和iBGP（内部BGP，用于AS内部路由器之间同步BGP信息）。
BGP的特点：可扩展性强，支持路由聚合和策略控制，适合大规模互联网环境。


IGP与EGP的功能及配合：

(1) IGP（Interior Gateway Protocol，内部网关协议）：

用于自治系统（AS）内部的路由选择。
常见协议有RIP、OSPF、IS-IS等。
主要负责AS内部各路由器之间的路由信息交换和最优路径选择。

(2) EGP（Exterior Gateway Protocol，外部网关协议）：

用于不同自治系统（AS）之间的路由选择。
目前实际应用中主要是BGP（边界网关协议）。
负责AS之间的路由信息交换，实现互联网范围的路由可达性。

(3) IGP与EGP的配合方式：

IGP负责AS内部的路由收敛和最优路径，EGP负责AS之间的路由传播和策略控制。
路由器在AS内部通过IGP学习和维护本地路由表，在AS边界通过EGP（如BGP）与其他AS交换路由信息。
通常AS内部的路由信息通过汇总后由EGP向外通告，EGP学到的外部路由也会注入到IGP中供内部主机访问外部网络。


RIP与OSPF详解：

(1) RIP（Routing Information Protocol，路由信息协议）：

基于距离向量（Distance Vector）算法的内部网关协议（IGP）。
路由器定期向相邻路由器广播自己的路由表，度量值为“跳数”（Hop Count），最大跳数为15，16表示不可达。
每30秒周期性更新，适合小型网络，配置简单。
优点：实现简单，易于配置和管理。
缺点：收敛慢，容易产生路由环路，最大跳数限制导致不适合大型网络，带宽利用率低。
典型应用：早期企业局域网、小型网络。

(2) OSPF（Open Shortest Path First，开放最短路径优先）：

基于链路状态（Link State）算法的内部网关协议（IGP）。
路由器通过洪泛方式向所有路由器通告链路状态信息，所有路由器获得完整的网络拓扑。
使用Dijkstra算法计算最短路径，度量值为“成本”（Cost），可根据带宽等灵活设定。
支持分层设计（区域Area），适合大规模网络，收敛速度快。
支持认证、安全、负载均衡、VLSM等高级特性。
优点：收敛快，扩展性强，适合大型复杂网络，支持多种网络类型。
缺点：实现和配置较复杂，对硬件资源要求较高。
典型应用：企业、运营商的大型网络环境。


Internet分层的作用：


简化网络设计：将复杂的网络通信过程分为多个层次，每层只关注自身功能，降低设计和实现难度。
便于标准化和互操作：每一层有明确的接口和协议标准，不同厂商的设备和协议可以互通。
易于维护和扩展：某一层的技术升级或更换不会影响到其他层，增强了网络的灵活性和可扩展性。
促进技术创新：各层可以独立发展新技术，推动网络整体进步。
有助于故障定位和管理：分层结构便于定位和排查网络问题，提高网络管理效率。
协议分层有概念化和结构化的优点。
降低复杂度、提高灵活性。

沙漏结构（hourglass）的意义：

采用单一的网络层协议（IP），所有网络都通过IP协议互联。
允许任意网络互通：只要支持IP的网络都能交换数据包。
应用与底层网络技术解耦：应用程序不依赖于底层网络类型，能在所有网络上运行。
支持IP层上下的同时创新：IP之上（如应用层协议）和IP之下（如链路层技术）都可以独立发展新技术。
但IP协议本身难以更改（如IPv4升级到IPv6非常困难），因为整个互联网都依赖于IP协议。


常见报文格式UDP：TCP：IPv4：IPv6：

NAT与IP-in-IP隧道详解：


(1) NAT（Network Address Translation，网络地址转换）：

NAT是一种在路由器或网关设备上实现的地址转换技术，用于在私有网络和公网之间转换IP地址。
主要类型：
静态NAT：一一映射，私有IP和公网IP固定对应。
动态NAT：从公网IP池中动态分配公网地址给私有IP。
NAPT（端口地址转换，PAT&#x2F;端口复用）：多个私有IP通过同一个公网IP出网，靠端口号区分不同连接。


作用：
节省公网IP地址，实现局域网主机共享上网。
隐藏内部网络结构，提高安全性。
支持地址重用和网络结构灵活调整。


NAT的实现只需修改IP包头的源&#x2F;目的地址和端口，不需要封装额外的IP头。

(2) IP-in-IP隧道：

IP-in-IP隧道是一种隧道协议，将一个IP数据包作为“数据”封装进另一个IP包中。
实现方式：
隧道入口（封装端）收到原始IP包后，加上新的外层IP头（源&#x2F;目的地址为隧道两端公网IP），再发送到网络。
隧道出口（解封端）收到后，去掉外层IP头，还原出原始IP包并继续转发。


作用：
实现不同网络或协议之间的互联，如IPv6 over IPv4、VPN、移动IP等。
可穿越不支持某些协议或地址的中间网络，实现私有网络互通。
提供虚拟专用通道，增强数据传输的灵活性和安全性。


IP-in-IP隧道本质是“IP包套IP包”，与NAT不同，NAT不需要使用IP-in-IP隧道。


SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一种应用层协议，用于在电子邮件系统中传输邮件。它负责邮件的发送和转发，常用于邮件客户端与邮件服务器、邮件服务器之间的邮件传递。SMTP使用TCP端口25，保证邮件可靠送达目标服务器，但本身不负责邮件的接收和存储，接收通常由POP3或IMAP协议完成。


例题：DNS欺骗攻击与加密认证、RSA私钥求解题目描述如下图所示，DNS，设计一个攻击，攻击者用主动攻击让 Alice 收到假的 response 。

DNS，设计一个攻击，攻击者用主动攻击让 alice 收到假的 response 。

服务器收到（m, Ks-(H(m))）问怎么判断是 s 发的？

上面用的是私钥，问可不可以用公钥加密？

这个加密算法可不可以防止第一问里面你写的攻击方法？

最后一题 RSA 算法：Na&#x3D;55，ea&#x3D;3，Nb&#x3D;33，eb&#x3D;13，求 a、b 私钥。



答案解析1. DNS欺骗攻击设计

攻击者可以通过伪造 DNS 响应包，抢在真实 DNS 服务器之前将假的 response 发给 Alice，使其缓存错误的域名-IP 映射。
具体方法：攻击者监听 Alice 的 DNS 查询请求，猜测或获取事务ID（Transaction ID），并伪造一个带有相同事务ID的响应包，提前返回给 Alice。
这样 Alice 会将攻击者伪造的 IP 地址作为目标域名的解析结果，导致流量被劫持或重定向。

2. 服务器收到（m, Ks-(H(m))）如何判断是 s 发的？

Ks- 表示用 s 的私钥对消息摘要 H(m) 进行签名。
服务器收到后，用 s 的公钥 Ks+ 验证签名：用 Ks+ 解密 Ks-(H(m))，得到 H(m)’，再与本地计算的 H(m) 比较。
若一致，则说明消息确实由 s 发出且未被篡改。

3. 上面用的是私钥，能否用公钥加密？

不能。公钥加密用于加密消息，保证机密性；私钥加密（签名）用于认证身份和完整性。
若用公钥加密，任何人都能用公钥加密消息，无法证明消息是 s 发出的。
数字签名必须用私钥加密（签名），公钥验证。

4. 该加密算法能否防止第一问的攻击？

可以防止。
因为只有合法的 s 拥有私钥，攻击者无法伪造合法签名，服务器可通过公钥验证签名，防止伪造响应。
即使攻击者能伪造 DNS 响应，也无法生成合法签名。

5. RSA私钥求解

Na&#x3D;55，ea&#x3D;3，Nb&#x3D;33，eb&#x3D;13。
求 a、b 的私钥：

（1）Na&#x3D;55，分解质因数：55&#x3D;5×11。

φ(Na) &#x3D; (5-1)×(11-1) &#x3D; 4×10 &#x3D; 40。
ea&#x3D;3，求 da，使 3×da ≡ 1 (mod 40)。
3×da&#x3D;1+40k，da&#x3D;27（因为3×27&#x3D;81，81-2×40&#x3D;1）。
a的私钥为 (Na&#x3D;55, da&#x3D;27)。

（2）Nb&#x3D;33，分解质因数：33&#x3D;3×11。

φ(Nb) &#x3D; (3-1)×(11-1) &#x3D; 2×10 &#x3D; 20。
eb&#x3D;13，求 db，使 13×db ≡ 1 (mod 20)。
13×db&#x3D;1+20k，db&#x3D;17（因为13×17&#x3D;221，221-11×20&#x3D;1）。
b的私钥为 (Nb&#x3D;33, db&#x3D;17)。


例题：五层协议“沙漏”结构与相关知识点题目
沙漏中间的协议是（ ）
协议分层的好处
互联网“沙漏”型的好处
TCP和UDP的区别
电子邮件使用的应用层协议

答案与解析1. 沙漏中间的协议是（ ）

答案：IP协议（Internet Protocol）。
解析：五层协议栈的“沙漏”结构中，最窄处是网络层的IP协议，所有上层协议（如TCP、UDP、ICMP等）和下层链路协议（如以太网、PPP等）都通过IP协议进行数据传递。

2. 协议分层的好处

降低复杂度：每层只关注本层功能，简化设计与实现。
易于标准化：各层接口明确，便于不同厂商设备互通。
便于维护和升级：某一层技术升级时，只要接口不变，不影响其他层。
促进互操作性：不同实现可兼容，促进网络发展。

3. 互联网“沙漏”型的好处

统一中间层（IP），简化互联：各种不同的物理网络和多样的应用协议都能通过IP互联。
促进创新：上层应用协议和下层链路技术可以独立发展，极大促进了互联网的扩展性和多样性。
降低成本：只需实现IP协议即可接入互联网，无需关心所有上层或下层细节。

4. TCP和UDP的区别



特性
TCP
UDP



连接方式
面向连接（三次握手）
无连接


可靠性
可靠，保证数据顺序和完整性
不可靠，可能丢包、乱序


流量控制
有
无


拥塞控制
有
无


速度
较慢
较快


适用场景
文件传输、网页、邮件等
视频、语音、DNS等


5. 电子邮件使用的应用层协议

SMTP（Simple Mail Transfer Protocol）：邮件发送协议。
POP3（Post Office Protocol 3）：邮件接收协议，下载到本地。
IMAP（Internet Message Access Protocol）：邮件接收协议，支持服务器端管理。


以太网最小帧长的计算逻辑以太网采用CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）机制。为了保证发送端在数据帧还未全部发送完时能检测到碰撞，帧的发送时间必须大于等于信号在网络中往返一次的传播时延。
（1）计算公式最小帧长（bit） &#x3D; 2 × 最大物理距离 &#x2F; 信号传播速率 × 带宽
简化为：最小帧长 &#x3D; 2 × 传播时延 × 带宽

传播时延 &#x3D; 最大距离 &#x2F; 信号传播速率
带宽单位需统一（如bit&#x2F;s）

（2）原理说明

如果帧太短，发送端可能在帧发完后才检测到碰撞，无法重发，导致冲突未被发现。
规定最小帧长，确保碰撞一定能被检测到。

（3）例题应用

例如最大距离500m，信号传播速率250m&#x2F;μs，带宽100Mbps：
传播时延 &#x3D; 500m &#x2F; 250m&#x2F;μs &#x3D; 2μs
最小帧长 &#x3D; 2 × 2μs × 100Mbps &#x3D; 4μs × 100Mbps &#x3D; 400bit &#x3D; 50字节




CRC校验计算举例假设：

数据D &#x3D; 1101011011（二进制）
生成多项式G &#x3D; 10011（二进制，4阶）

计算步骤：

在数据D后补4个0（G为4阶，多补4位）：1101011011 0000
用补0后的数据与G做二进制模2除法（异或运算）：
11010 ÷ 10011 → 01001
10011 ÷ 10011 → 00000
10110 ÷ 10011 → 00101
…（依次进行，直到最后一位）


最终余数为4位（假设为R），即为CRC校验码。
发送时，数据D与CRC校验码拼接一起发送。

结果说明：

接收方收到后，用相同的G对收到的数据（含CRC）做模2除法，若余数为0，则无差错。

简化示例：

D &#x3D; 1101，G &#x3D; 1011（3阶）
D补0：1101000
1101 ÷ 1011 → 0110
0110 ÷ 1011 → 0110（不足除，移下一位）
01100 ÷ 1011 → 0101
01010 ÷ 1011 → 0111
01110 ÷ 1011 → 0105
01010 ÷ 1011 → 0111
01110 ÷ 1011 → 0105
最终余数假设为101
发送数据：1101 101


奇偶校验（Parity Checking）原理奇偶校验是一种简单的数据链路层差错检测方法，主要用于检测单比特错误。
1. 单比特奇偶校验（Single Bit Parity）

在每组数据后面加1位校验位（parity bit）。
发送方根据数据中1的个数决定校验位取0或1，使得整个比特流中1的个数为偶数（偶校验）或奇数（奇校验）。
接收方收到数据后，重新计算1的个数，若不符则说明发生了单比特错误。
只能检测单个比特错误，无法纠正错误，也无法检测偶数个比特同时出错。

2. 二维奇偶校验（Two Dimensional Bit Parity）

将数据按行和列分别加上奇偶校验位。
每一行和每一列都增加一个校验位，形成一个校验矩阵。
能检测并定位单比特错误（可纠正），也能检测部分双比特错误。
检测能力比单比特奇偶校验更强。

应用说明：

奇偶校验实现简单，适合对可靠性要求不高的场景。
主要用于数据链路层的差错检测。


信道划分协议详解信道划分协议（Channelization Protocols）是一类将共享信道资源在多个用户之间进行物理或逻辑划分，使多个用户可以同时或有序地使用信道的多路访问协议。其核心思想是将信道分割为若干互不干扰的子信道，每个用户占用不同的子信道，从而避免冲突。
常见的信道划分协议有：
1. 时分多路复用（TDMA, Time Division Multiple Access）
将信道按时间划分为若干时隙，每个用户在分配到的时隙内独占信道发送数据。
各用户轮流占用信道，互不干扰。
适合同步环境，时钟同步要求高。
优点：无冲突，时延可控，适合实时业务。
缺点：信道利用率受限于分配，空闲时隙会浪费带宽。

2. 频分多路复用（FDMA, Frequency Division Multiple Access）
将信道的频带划分为若干互不重叠的频段，每个用户占用不同的频段进行通信。
各用户可同时发送，互不干扰。
典型应用：传统模拟电话、无线电广播。
优点：实现简单，互不干扰。
缺点：频谱利用率有限，频带划分固定，灵活性差。

3. 码分多路复用（CDMA, Code Division Multiple Access）
所有用户在同一时间、同一频带上发送数据，但每个用户使用不同的正交码对数据进行编码。
接收方用相同的码解码，能区分不同用户的数据。
典型应用：3G移动通信。
优点：抗干扰能力强，频谱利用率高，支持动态接入。
缺点：实现复杂，对码的正交性要求高。

4. 其他信道划分方式
波分多路复用（WDMA）：用于光纤通信，将不同波长分配给不同用户。
空分多路复用（SDMA）：通过空间定向天线等手段区分用户。

总结：信道划分协议通过时间、频率、码等资源的分割，实现多个用户高效、无冲突地共享信道，广泛应用于有线和无线通信系统。

实践原则：保持各层独立主机和路由器接口除了网络层地址（如IP地址）之外还有MAC地址，这样设计有以下原因：

局域网为任意网络层协议而设计，MAC地址是“中性”的，不依赖于IP或特定协议。如果适配器只用IP地址而没有MAC地址，就无法支持如IPX、DECnet等其他网络层协议。
如果适配器使用网络层地址而不是MAC地址，网络层地址必须存储在适配器RAM中，每次适配器移动或断电都要重新配置，管理复杂。
另一种做法是适配器不使用任何地址，让其接收所有帧并上传，由网络层软件判断是否匹配，但这样会导致主机处理大量无关帧，效率低下。

因此，为了使网络体系结构中各层次成为独立模块，不同层次需要有各自的寻址方案：

应用层：主机名
网络层：IP地址
数据链路层：MAC地址

这种分层寻址方案保证了各层的独立性和灵活性。

有线局域网与无线局域网知识总结一、有线局域网（Wired LAN）
定义与常见类型

有线局域网是指通过物理介质（如双绞线、同轴电缆、光纤等）连接的局部范围内的计算机网络。
典型代表：以太网（Ethernet）、令牌环（Token Ring）、FDDI等。


以太网（Ethernet）

最常用的有线局域网标准，采用星型或总线型拓扑结构。
采用MAC地址寻址，数据链路层协议。
介质访问控制：CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）。
标准最小帧长64字节，最大1518字节。
速率：10Mbps、100Mbps、1Gbps、10Gbps等。
物理介质：双绞线、光纤、同轴电缆。
交换机（Switch）是现代以太网的核心设备。


令牌环（Token Ring）

采用环形拓扑，令牌传递机制避免冲突。
只有持有令牌的节点才能发送数据。
速率常见为4Mbps、16Mbps。
现已较少使用。


有线局域网的优缺点

优点：带宽高、稳定性好、抗干扰能力强、安全性高。
缺点：布线复杂、灵活性差、扩展性有限。



二、无线局域网（Wireless LAN, WLAN）
定义与标准

无线局域网通过无线电波（如2.4GHz、5GHz）实现设备间的通信，无需物理布线。
主要标准：IEEE 802.11系列（即Wi-Fi）。


Wi-Fi（IEEE 802.11）

采用星型拓扑，中心设备为无线接入点（AP, Access Point）。
终端通过无线方式与AP通信，AP再与有线网络连接。
速率：802.11b（11Mbps）、802.11g（54Mbps）、802.11n（600Mbps）、802.11ac&#x2F;ax（上千Mbps）。
频段：2.4GHz、5GHz，部分新标准支持6GHz。
介质访问控制：CSMA&#x2F;CA（载波监听多路访问&#x2F;冲突避免），采用随机退避、ACK确认等机制，避免无线环境下的冲突。
支持漫游、加密（WEP、WPA、WPA2、WPA3）等安全机制。


无线局域网的优缺点

优点：布线灵活、易于扩展、支持移动性、部署方便。
缺点：带宽有限、易受干扰、安全性相对较弱、信号覆盖有限。



三、有线与无线局域网的对比


特性
有线局域网（Ethernet等）
无线局域网（Wi-Fi等）



介质
双绞线&#x2F;光纤&#x2F;同轴电缆
无线电波


带宽
高（10M~10Gbps）
较低（几十M~几Gbps）


稳定性
高
易受干扰


安全性
高
需加密防护


灵活性
差
高


组网方式
星型&#x2F;总线&#x2F;环型
星型（AP为中心）


介质访问协议
CSMA&#x2F;CD、令牌环等
CSMA&#x2F;CA


典型设备
交换机、网卡、路由器
无线AP、无线网卡


四、应用场景
有线局域网：企业、数据中心、对带宽和安全要求高的场所。
无线局域网：家庭、办公区、公共场所、移动办公等。


交换机的功能简述
交换机（Switch）是局域网中常用的数据链路层设备，主要功能是根据数据帧的目的MAC地址，在局域网内实现高效的数据转发。
维护MAC地址表：自动学习和记录各端口对应的MAC地址，实现帧的定向转发。
帧转发与过滤：只将数据帧转发到目标主机所在端口，减少广播和冲突，提高网络效率。
支持全双工通信和端口隔离，提升带宽利用率。
支持VLAN划分，实现逻辑隔离和安全管理。
可进行环路检测与生成树协议（STP）防止广播风暴。


广播风暴详解1. 概念

广播风暴（Broadcast Storm）是指在局域网中，广播帧（如ARP请求、未知目的MAC的数据帧等）大量泛滥，导致网络带宽被严重占用，网络性能急剧下降甚至瘫痪的现象。

2. 产生原因

以太网交换机在收到目的MAC地址未知的数据帧时，会将该帧广播到所有端口。
当网络中存在环路（如多个交换机或网桥连接成环），广播帧会在环路中不断循环、复制，数量呈指数级增长。
广播风暴也可能由病毒、错误配置或大量ARP请求等异常流量引发。

3. 危害

占用大量带宽，导致正常数据无法传输。
交换机、主机CPU资源被大量无用广播帧消耗，系统响应变慢甚至崩溃。
网络延迟剧增，丢包严重，业务中断。

4. 典型场景

多台交换机或网桥连接成环，未启用生成树协议（STP）。
局域网内出现病毒或蠕虫，疯狂发送广播包。
大量主机同时发起ARP请求，或网络中存在ARP欺骗攻击。

5. 预防与解决方法

启用生成树协议（STP），自动阻断环路，保证网络拓扑无环。
合理划分VLAN，限制广播域范围。
配置广播风暴抑制（Broadcast Storm Control）功能，限制端口广播流量。
加强网络安全管理，防止恶意广播流量。

6. 总结

广播风暴是局域网设计和管理中必须重点防范的问题，合理的网络结构和管理措施是防止广播风暴的关键。


DHCP协议简介DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一种应用层协议，用于在IP网络中自动为主机分配IP地址及相关网络配置信息（如子网掩码、网关、DNS服务器等）。
主要功能：

自动分配IP地址，避免手动配置，提高管理效率。
支持IP地址的动态分配、自动回收和续租。
可集中管理整个网络的IP地址资源。

工作流程：

发现（Discover）： 客户端广播DHCP Discover报文，寻找DHCP服务器。
提供（Offer）： DHCP服务器响应，提供可用IP地址和配置信息。
请求（Request）： 客户端选择一个服务器，广播DHCP Request报文，申请该IP。
确认（ACK）： 服务器确认分配，发送DHCP ACK报文，客户端获得IP地址。

优点：

简化网络管理，适合大中型网络。
支持移动设备和临时接入主机的自动配置。

应用场景：

企业、校园、家庭等各种IP网络环境。


ARP与DHCP的层次与作用对比
DHCP（动态主机配置协议）：属于应用层协议，主要作用是为主机自动分配IP地址及相关网络参数（如网关、DNS等）。

典型流程：主机刚接入网络时，通过广播方式向DHCP服务器请求分配IP地址。
解决“主机如何获得IP地址”的问题。


ARP（地址解析协议）：属于数据链路层与网络层之间的协议，主要作用是将已知的IP地址解析为对应的MAC地址。

典型流程：主机已知目标IP地址，但不知道其MAC地址时，通过广播ARP请求，获得目标主机的MAC地址。
解决“主机如何通过IP找到MAC地址”的问题。



总结：

DHCP用于“找IP地址”，属于应用层，负责主机的网络参数自动配置。
ARP用于“找MAC地址”，属于网络层与数据链路层之间，负责IP到MAC的映射。
两者都采用广播、缓存和软状态等机制，但服务对象和协议层次不同。


发现机制（Discovery Mechanisms）在网络中，常见的发现机制主要有两种：

广播（Broadcast）机制

典型协议：ARP、DHCP。
工作方式：通过广播方式在局域网内发现目标（如ARP查找MAC地址、DHCP分配IP地址）。
优点：
无需预先配置，零配置，适合即插即用。
没有中心化的单点故障，去中心化。


缺点：
采用泛洪（flooding）方式，随着网络规模增大，广播流量剧增，扩展性差。
只适合小型或局部网络。




目录服务（Directory Service）机制

典型协议：DNS。
工作方式：通过集中式的目录服务进行资源发现和名称解析。
优点：
无需广播，具备良好的可扩展性，适合大规模网络。


缺点：
目录服务的根节点存在被攻击或失效的风险（缓存机制非常关键）。
需要预先配置（如本地DNS、根服务器等）以实现引导和启动。





总结对比：

广播机制适合小规模、无需配置的场景，但不适合大规模网络。
目录服务机制适合大规模网络，但需要一定的配置和容错设计。


相关例子：ARP、DHCP采用广播发现，DNS采用目录服务发现。


CSMA&#x2F;CD（载波监听多路访问&#x2F;冲突检测）原理与机制CSMA&#x2F;CD（Carrier Sense Multiple Access with Collision Detection）是以太网中经典的介质访问控制协议，主要用于总线型或集线器型（半双工）以太网环境下多台主机共享同一信道时的数据传输协调。
工作原理：

载波监听（Carrier Sense）：主机在发送数据前，先监听信道是否空闲，只有信道空闲时才开始发送。
多路访问（Multiple Access）：多台主机可同时接入同一信道，具备竞争性。
冲突检测（Collision Detection）：如果两台主机几乎同时检测到信道空闲并开始发送，数据会发生冲突。主机在发送数据时持续监听信道，若检测到信号异常（冲突），立即停止发送。
退避重传（Backoff）：发生冲突后，主机会发送阻塞信号（Jamming Signal），然后各自等待一个随机退避时间后再次尝试发送。退避时间采用二进制指数退避算法，冲突次数越多，等待时间越长。

特点与应用：

适用于传统总线型、集线器型以太网（半双工），现代全双工交换式以太网已不再使用CSMA&#x2F;CD。
随着网络负载增加，冲突概率上升，信道利用率下降。
以太网最小帧长的设计与CSMA&#x2F;CD机制密切相关，保证冲突能被检测到。

局限性：

只适用于半双工、共享信道的环境。
在全双工和交换式以太网中已被淘汰。

总结：CSMA&#x2F;CD通过监听信道、检测冲突和随机退避，有效协调了多主机对共享信道的访问，是经典以太网的核心机制之一。

CSMA&#x2F;CA（载波监听多路访问&#x2F;冲突避免）原理与机制CSMA&#x2F;CA（Carrier Sense Multiple Access with Collision Avoidance）是无线局域网（如Wi-Fi&#x2F;IEEE 802.11）中常用的介质访问控制协议，用于协调多台设备对共享无线信道的访问，避免数据冲突。
工作原理：

载波监听（Carrier Sense）：终端在发送数据前，先监听信道是否空闲。
冲突避免（Collision Avoidance）：
若信道空闲，终端等待一个随机退避时间（Backoff），若期间信道仍空闲，则开始发送。
若信道忙，终端持续监听并等待信道空闲后再退避。
采用随机退避机制，减少多个终端同时发送的概率。


确认机制（ACK）：数据帧发送后，接收方需返回ACK确认帧，发送方收到ACK才认为发送成功，否则重传。
RTS&#x2F;CTS机制（可选）：为进一步减少冲突，发送方可先发送RTS（请求发送）帧，接收方回复CTS（清除发送）帧，收到CTS后再正式发送数据。
该机制可有效解决“隐藏终端”问题。



特点与应用：

主要用于无线局域网（如Wi-Fi），适合广播式、易受干扰的无线环境。
由于无线信道无法像有线以太网那样检测冲突（无法边发边听），采用冲突避免而非冲突检测。
通过ACK和RTS&#x2F;CTS机制提高可靠性和信道利用率。

局限性：

存在信道占用、退避等待等开销，信道利用率受限。
在高密度或高负载环境下，冲突和重传概率仍可能较高。

总结：CSMA&#x2F;CA通过监听信道、随机退避、确认应答和可选的RTS&#x2F;CTS机制，有效减少了无线环境下的冲突，是无线局域网的核心介质访问控制机制。

CSMA&#x2F;CD 与 CSMA&#x2F;CA 的区别总结


对比项
CSMA&#x2F;CD（冲突检测）
CSMA&#x2F;CA（冲突避免）



典型应用场景
有线以太网（Ethernet，半双工）
无线局域网（Wi-Fi&#x2F;IEEE 802.11）


介质类型
有线，信号可检测
无线，信号难以边发边听


冲突处理方式
允许冲突发生，检测到冲突后停止发送并退避
通过退避和控制机制尽量避免冲突发生


主要机制
监听信道、检测冲突、冲突后退避重传
监听信道、随机退避、ACK确认、RTS&#x2F;CTS机制


能否检测冲突
可以（边发边听）
不能（无线无法边发边听）


退避算法
二进制指数退避
随机退避


可靠性机制
无确认机制
ACK确认机制，RTS&#x2F;CTS可选


适用网络结构
总线型&#x2F;集线器型有线网络
无线广播式网络


现状
现代全双工以太网已不再使用
仍为Wi-Fi等无线局域网的核心机制


简要总结：

CSMA&#x2F;CD 适用于有线以太网，允许冲突发生并检测冲突，依赖于信号可检测。
CSMA&#x2F;CA 适用于无线局域网，因无线信道无法检测冲突，采用冲突避免和确认机制。
两者都属于多路访问协议，但根据物理介质和应用场景采用不同的冲突处理策略。


网桥的作用与工作原理1. 网桥的作用

网桥（Bridge）是一种工作在数据链路层的网络互联设备，用于连接两个或多个局域网段，实现不同局域网之间的数据转发和隔离冲突域。
能够根据MAC地址转发数据帧，减少广播域范围，提高网络性能。
典型应用于以太网分段、扩展局域网、隔离冲突域等场景。

2. 网桥的工作原理

网桥通过监听经过的数据帧，自动学习源MAC地址与端口的对应关系，建立转发表（MAC地址表）。
当接收到数据帧时，查找转发表：
若目标MAC地址已在表中，定向转发到对应端口。
若未知，则广播该帧到除接收端口外的所有端口。


通过地址学习和转发表，实现帧的高效转发和冲突域隔离。

3. 网桥的路由机制

转发表（Forwarding Table）：记录MAC地址与端口的映射关系，实现定向转发。
地址学习（Address Learning）：自动学习源MAC地址，动态维护转发表。
生成树算法（Spanning Tree Protocol, STP）：为防止网络环路，网桥间运行生成树协议，自动阻断冗余链路，形成无环拓扑，避免广播风暴。
路由发现机制：通过生成树协议和地址学习，自动发现网络结构和最优转发路径，无需人工配置。

总结：

网桥通过地址学习和转发表实现高效转发，通过生成树协议防止环路和广播风暴，是局域网互联和分段的重要设备。


集线器（Hub）的作用与原理1. 集线器的定义与结构

集线器（Hub）是局域网中常见的物理层设备，常用于星型拓扑（star layout）结构的网络。
在星型拓扑中，所有终端（主机）通过两根线（发送和接收）与中心的集线器相连。

2. 工作原理

Hub 的主要功能类似于中继器（Repeater），属于“无智能”设备。
当某个终端发送数据时，Hub 会将收到的信号复制并转发到所有其他端口（即所有其他终端）。
Hub 不会分析数据内容，也不区分目标，只是简单地广播信号。

3. 物理与逻辑结构

物理上，Hub 组网为星型结构（每个终端都连到中心 Hub）。
逻辑上，Hub 组网等价于总线型（bus）：任何一个终端发出的数据，所有终端都能收到。
如果有两个终端同时发送数据，会发生冲突（collision），所有终端都处于同一个冲突域。

4. 特点与局限

Hub 不具备数据定向转发能力，所有端口共享带宽，冲突概率高。
适用于小型、低速、对性能要求不高的局域网。
现代以太网已被交换机（Switch）取代，Hub 基本淘汰。

5. 小结

Hub 是星型拓扑的中心设备，起到信号中继和广播的作用。
物理上为星型，逻辑上为总线型，所有终端共享冲突域。
不具备智能转发和隔离冲突域的能力。


IEEE 802.11 无线局域网体系结构（WLAN Architecture）1. Station（STA，站点）

指具备IEEE 802.11标准MAC和物理层功能的无线设备，如无线网卡、手机、笔记本等终端。

2. Access Point（AP，无线接入点）

作为无线终端与分布式系统（DS）之间的桥梁，负责协调和管理无线终端的接入。
通过无线信道为终端提供接入服务。

3. Basic Service Set（BSS，基本服务集）

由一个AP和若干STA组成的最小无线局域网单元。
一个BSS通常覆盖一个物理区域（如一个房间），由AP协调管理。

4. Extended Service Set（ESS，扩展服务集）

由多个BSS通过分布式系统（DS）互联组成。
DS可以是交换机、有线网络或无线网络。
ESS对用户呈现为一个单一的逻辑局域网，实现无线漫游和大范围覆盖。
通过Portal（如路由器）实现与有线LAN&#x2F;Internet的互通。

5. Distribution System（DS，分布式系统）

用于连接多个BSS和集成有线LAN，形成一个ESS。
DS可采用多种实现方式（如以太网交换机、无线Mesh等）。

6. 体系结构图解说明

图中展示了多个BSS（每个BSS有一个AP和若干STA），通过DS互联，组成一个ESS。
Portal实现ESS与有线LAN&#x2F;Internet的连接。
ESS为用户提供无缝漫游和统一的无线局域网服务。

7. 小结

IEEE 802.11 WLAN采用分层、分区的体系结构，支持灵活扩展和大范围覆盖。
关键组件包括STA、AP、BSS、ESS、DS和Portal。
ESS实现了多个BSS的互联和统一管理，是企业和校园无线网络的基础架构。


IEEE 802.11 帧间隔优先级机制（SIFS、PIFS、DIFS）IEEE 802.11 无线局域网采用三种不同的帧间隔（IFS, Inter Frame Space）来实现信道访问的优先级控制，分别是：

SIFS（Short Inter Frame Space，短帧间隔）
最短的IFS，优先级最高。
用于所有需要立即响应的场景，如ACK、CTS、数据帧之间的连续发送等。


PIFS（Point Coordination Function IFS，点协调功能帧间隔）
中等长度的IFS。
主要由中心控制器（AP）在PCF（点协调功能）模式下发起轮询时使用。


DIFS（Distributed Coordination Function IFS，分布式协调功能帧间隔）
最长的IFS，优先级最低。
用于普通终端争用信道时的异步数据帧发送。



三者的关系为：SIFS &lt; PIFS &lt; DIFS。
这种设计保证了：

需要快速响应的帧（如ACK、CTS）能优先获得信道，减少时延。
控制帧（如AP轮询）优先于普通数据帧。
普通数据帧需等待最长的DIFS，优先级最低。

下图为三种IFS的相对长度和优先级关系示意：
DIFSPIFSSIFSFrame |&lt;--SIFS--&gt;| Frame |&lt;--PIFS--&gt;| Frame |&lt;--DIFS--&gt;| Frame

通过这种分级帧间隔机制，IEEE 802.11 实现了无线信道访问的公平性和高效性。

IEEE 802.11 点协调功能（PCF）与超级帧机制1. 点协调功能（PCF, Point Coordination Function）
PCF是一种中心化的无线介质访问控制机制，由接入点（AP）作为点协调器（Point Coordinator, PC）统一调度。
AP定期以轮询（round-robin）方式向各终端（STA）发起轮询（poll），被轮询到的终端才能发送数据，避免冲突，适合时延敏感业务。
AP在发起轮询时使用PIFS（优先级高于普通终端的DIFS），可以抢占信道，锁定异步流量，保证轮询和响应期间的信道独占。
终端收到轮询后，若有数据需发送，则用SIFS（最高优先级）立即响应。
若AP未收到响应，在预期时间内会继续轮询下一个终端，直到本轮结束。

2. 超级帧（Super-frame）机制
超级帧由PCF定义，将时间划分为轮询期和争用期两部分。
轮询期（contend-free period）：AP轮询所有终端，保证无冲突通信。
争用期（contention period）：允许普通终端采用DCF机制争用信道，进行异步通信。


超级帧开始时，AP通过beacon帧宣布超级帧的起点，并创建无冲突期。
超级帧结束时，AP再次用PIFS争用信道，进入下一个超级帧周期。
这样既保证了时延敏感业务的服务质量，又兼容普通异步业务的接入。


超级帧机制通过轮询和争用期的划分，实现了无线局域网中有中心调度与分布式竞争的结合，提升了服务质量和信道利用率。


IEEE 802.11 分布式协调功能（DCF）原理与工作流程1. DCF（Distributed Coordination Function）原理
DCF是IEEE 802.11无线局域网中最基本、最常用的介质访问控制机制，采用**CSMA&#x2F;CA（载波监听多路访问&#x2F;冲突避免）**协议。
所有终端平等竞争信道，无中心调度，适合异步、分布式的无线通信环境。
由于无线环境无法像有线以太网那样检测冲突（不能边发边听），DCF采用冲突避免和确认机制来保证数据可靠传输。

2. DCF的完整工作流程
监听信道（Carrier Sensing）

终端准备发送数据前，先监听信道是否空闲。
若信道忙，则持续监听，直到信道空闲。


等待DIFS（Distributed Inter Frame Space）

信道空闲后，终端需等待一个DIFS时间（最长的帧间隔，优先级最低），以保证高优先级帧（如SIFS、PIFS）优先发送。


随机退避（Backoff）机制

若有多个终端同时等待发送，为避免冲突，每个终端在DIFS后会选择一个随机退避时间（Backoff Time）。
退避时间以时隙为单位，在[0, CW-1]之间随机选择（CW为争用窗口）。
退避计数在信道空闲时递减，若信道变忙则暂停计数，等信道再次空闲后继续。


发送数据帧

退避计数减为0时，终端开始发送数据帧。


等待ACK确认

数据帧发送后，接收方在SIFS（最短帧间隔）后立即返回ACK确认帧。
发送方收到ACK，认为本次发送成功；若未收到ACK，则认为发生冲突或丢包，进入重传流程。


重传与退避窗口调整

若发送失败，终端将CW加倍（指数退避），重新选择退避时间，重复上述流程，直到发送成功或达到最大重传次数。



3. DCF的关键机制与特点
CSMA&#x2F;CA：通过监听信道和随机退避，尽量避免冲突发生。
ACK确认：每次数据发送都需接收方返回ACK，保证可靠性。
无冲突检测：无线环境无法检测冲突，只能通过ACK机制间接判断。
优先级控制：通过不同的IFS（SIFS、PIFS、DIFS）实现帧类型的优先级调度。
RTS&#x2F;CTS机制（可选）：为解决隐藏终端问题，可在数据发送前先交换RTS&#x2F;CTS帧，进一步减少冲突。


DCF机制保证了无线局域网中各终端公平、有效地竞争信道，适用于大多数Wi-Fi应用场景。


解决隐藏终端问题在无线局域网中，隐藏终端问题是指两个终端A和C虽然都能与接入点B通信，但A和C之间互相不可见（即彼此信号覆盖不到），导致它们可能会同时向B发送数据，从而发生冲突，但A和C无法直接检测到对方的存在。
1. RTS&#x2F;CTS机制IEEE 802.11为了解决隐藏终端问题，引入了RTS&#x2F;CTS（Request to Send &#x2F; Clear to Send）机制：

发送前协商：发送方先发送RTS帧（请求发送）给接入点（或目标终端），请求占用信道。
接收方响应：接收方收到RTS后，若信道空闲，则回复CTS帧（允许发送）。
通知周围终端：收到CTS帧的所有终端会在指定时间内避免发送数据，防止冲突。
数据发送：发送方收到CTS后，立即发送数据帧，保证数据传输期间信道独占。
ACK确认：数据帧发送完毕后，接收方返回ACK确认帧。

通过RTS&#x2F;CTS机制，即使A和C互不可见，只要它们都能收到B的CTS，就能避免同时发送数据，减少冲突。

802.11的帧类型和帧格式1. 802.11帧类型IEEE 802.11定义了三大类帧类型：

管理帧（Management Frame）：用于网络的建立、维护和终止，如Beacon、Probe、Authentication、Association等。
控制帧（Control Frame）：用于信道控制和数据传输的协作，如RTS、CTS、ACK、PS-Poll等。
数据帧（Data Frame）：用于实际的数据传输。

2. 802.11帧格式典型的802.11数据帧格式如下：



字段
说明



Frame Control
帧类型、子类型、控制信息


Duration&#x2F;ID
信道占用时间或标识


Address 1
接收方地址


Address 2
发送方地址


Address 3
BSSID或目的&#x2F;源地址


Sequence Control
序列号、分片号


Address 4
（仅在WDS时使用）


Payload
数据载荷


crc
帧校验序列



802.11帧最多可包含4个地址字段，支持多种转发场景（如AP、STA、分布式系统等）。
帧控制字段包含帧类型、子类型、加密、重传等控制信息。



802.11与以太网帧格式比较


对比项
802.11帧格式
以太网帧格式



地址字段
最多4个（支持AP、STA、DS等场景）
2个（源MAC、目的MAC）


帧类型
管理帧、控制帧、数据帧
仅数据帧


控制字段
帧控制、序列控制、持续时间等
类型&#x2F;长度字段


校验
FCS
FCS


适用场景
无线局域网，支持多跳、漫游
有线局域网，点对点或广播


其他
支持加密、分片、功率管理等
不支持



802.11帧结构更复杂，适应无线环境的多样需求，如漫游、功率管理、加密等。
以太网帧结构简单，主要用于有线点对点或广播通信。


非对称加密算法：RSA算法1. 密钥生成过程
选择两个大素数：随机选择两个足够大的素数p和q。
计算模数n：n &#x3D; p × q，n将作为公钥和私钥的一部分。
计算欧拉函数φ(n)：φ(n) &#x3D; (p-1) × (q-1)。
选择公钥指数e：选择一个与φ(n)互质的整数e（1 &lt; e &lt; φ(n)），常用65537。
计算私钥指数d：d是e关于φ(n)的模反元素，即满足 e × d ≡ 1 (mod φ(n))。
公钥和私钥：
公钥：(n, e)
私钥：(n, d)



2. RSA加密和解密计算过程
加密过程：明文M，密文C的计算公式为：C &#x3D; M^e mod n

解密过程：密文C，明文M的计算公式为：M &#x3D; C^d mod n


3. 原理说明
RSA是一种典型的公钥加密算法，属于非对称加密，安全性基于大数分解难题。
加密密钥和解密密钥不同，公钥可公开，私钥需保密。
既可用于加密数据，也可用于数字签名（用私钥加密摘要，公钥验证）。


RSA算法广泛应用于数据加密、身份认证和数字签名等场景，是现代网络安全的基础算法之一。


公钥系统相关知识详解1. 公钥加密机制的组成元素
公钥（Public Key）与私钥（Private Key）：每个用户拥有一对密钥，公钥公开，私钥保密。
加密算法：如RSA、ElGamal等，利用公钥加密、私钥解密，实现机密性。
签名算法：用私钥对消息摘要签名，公钥验证签名，实现认证与完整性。
密钥分发与管理：如何安全地分发和管理公钥，防止伪造和中间人攻击。

2. 加密和数字签名
加密：发送方用接收方的公钥加密消息，只有接收方能用私钥解密，保证机密性。
数字签名：发送方用自己的私钥对消息摘要加密（签名），接收方用发送方公钥验证签名，保证消息来源和完整性，防止否认。

3. Diffie-Hellman密钥交换过程
Diffie-Hellman是一种安全的密钥协商协议，允许双方在不安全信道上协商出一个共享密钥。
过程简述：
双方约定一个大素数p和基g。
A选择随机数a，计算A &#x3D; g^a mod p，发送给B。
B选择随机数b，计算B &#x3D; g^b mod p，发送给A。
A计算共享密钥K &#x3D; B^a mod p，B计算K &#x3D; A^b mod p，结果相同。


特点：密钥协商过程即使被窃听，攻击者也无法推算出最终密钥（基于离散对数难题）。

4. 数字证书的概念和构造，CA
数字证书（Digital Certificate）：由权威机构（CA，证书授权中心）签发，绑定公钥与身份信息，防止公钥伪造。
内容：持有者身份、公钥、有效期、CA签名等。
CA（Certificate Authority）：负责验证身份、签发和吊销证书，是信任链的根。
作用：通过证书链和CA签名，用户可验证对方公钥的真实性，防止中间人攻击。

5. 安全电子邮件系统设计
目标：保证邮件的机密性、完整性、认证和不可否认性。
常用方案：
加密：用收件人公钥加密邮件内容，防止被窃听。
数字签名：发件人用私钥签名邮件，收件人用公钥验证，保证来源和内容未被篡改。
数字证书：用于分发和验证公钥，防止伪造。


典型协议：PGP（Pretty Good Privacy）、S&#x2F;MIME（安全多用途互联网邮件扩展）。
流程：
发件人对邮件内容做摘要并签名。
用收件人公钥加密邮件和签名。
收件人用私钥解密，再用发件人公钥验证签名。




总结：公钥系统通过加密、签名、密钥交换和数字证书等机制，保障了网络通信的安全性和可靠性，广泛应用于HTTPS、VPN、安全邮件等场景。

NAT原理及优缺点**NAT（Network Address Translation，网络地址转换）**是一种将私有网络地址与公网地址进行转换的技术，常用于局域网主机共享上网。

原理：NAT设备（如路由器）在数据包通过时，将私有IP地址和端口号转换为公网IP和端口号，返回时再转换回来。
类型：
静态NAT：一一映射，私有IP和公网IP固定对应。
动态NAT：从公网IP池中动态分配公网地址。
NAPT（端口复用）：多个私有IP通过同一公网IP出网，靠端口号区分。


优点：
节省公网IP地址资源。
隐藏内部网络结构，提高安全性。
支持局域网主机共享上网。


缺点：
破坏端到端通信，某些协议（如P2P、VoIP）兼容性差。
需要特殊处理端口映射和某些应用层协议。
影响IP包头校验和，增加处理开销。




ARP地址解析原理和流程**ARP（Address Resolution Protocol，地址解析协议）**用于将IP地址解析为对应的MAC地址，工作在网络层与数据链路层之间。

原理：主机已知目标IP地址，但不知道其MAC地址时，通过ARP协议查询。
流程：
主机在局域网内广播ARP请求包，询问“谁是这个IP地址，请告诉我你的MAC地址”。
目标主机收到后，回复ARP响应包，告知自己的MAC地址。
发送方收到响应后，将IP-MAC映射缓存到本地ARP表中，后续直接使用。


特点：
采用广播方式，适合局域网。
有ARP缓存，减少频繁广播。
存在ARP欺骗等安全隐患。




DHCP动态地址获取的过程**DHCP（Dynamic Host Configuration Protocol）**用于自动为主机分配IP地址及相关网络参数。

流程：
Discover：客户端广播DHCP Discover报文，寻找DHCP服务器。
Offer：服务器响应，提供可用IP地址和配置信息（DHCP Offer）。
Request：客户端选择一个服务器，广播DHCP Request报文，申请该IP。
ACK：服务器确认分配，发送DHCP ACK报文，客户端获得IP地址。


优点：
自动分配IP，简化管理。
支持IP地址动态分配、回收和续租。


应用场景：企业、校园、家庭等各种IP网络环境。


ICMP：用于发送出错信息，Ping和traceroute的实现原理**ICMP（Internet Control Message Protocol，互联网控制报文协议）**是IP协议的辅助协议，主要用于发送网络错误报告和诊断信息。

作用：
发送网络层错误信息（如目标不可达、超时等）。
支持网络诊断工具（如Ping、traceroute）。



Ping原理
Ping利用ICMP的Echo Request（回显请求）和Echo Reply（回显应答）报文测试主机连通性和时延。
流程：发送方向目标主机发送ICMP Echo Request，目标主机收到后回复Echo Reply，发送方统计往返时间和丢包率。

Traceroute原理
Traceroute用于探测数据包到目标主机所经过的路由路径。
实现方式：发送TTL（生存时间）递增的IP包，每经过一个路由器TTL减1，TTL为0时路由器返回ICMP超时报文，发送方据此确定路径上的每一跳。
最终目标主机收到包后返回ICMP端口不可达或Echo Reply，路径探测完成。


总结：  

NAT实现私有网络与公网的地址转换，节省IP资源但影响端到端通信。
ARP实现IP到MAC的映射，保证局域网内通信。
DHCP自动分配IP地址，简化网络管理。
ICMP用于网络错误报告和诊断，Ping和traceroute是常用的网络测试工具。


自治系统与路由方式详解1. IGP与EGP的概念
自治系统（AS, Autonomous System）：由同一技术管理和路由策略控制的一组IP网络和路由器，通常由一个运营商或大型机构管理。
IGP（Interior Gateway Protocol，内部网关协议）：用于AS内部各路由器之间的路由信息交换和路径选择，如RIP、OSPF等。
EGP（Exterior Gateway Protocol，外部网关协议）：用于不同AS之间的路由信息交换和路径选择，当前主要指BGP。

2. 内部路由协议（IGP）
距离向量协议（RIP, Routing Information Protocol）

基于距离向量算法，每个路由器定期向邻居广播自己的路由表。
跳数作为度量，最大跳数为15，16表示不可达。
实现简单，适合小型网络，但收敛慢，易产生环路。


链路状态协议（OSPF, Open Shortest Path First）

基于链路状态算法，路由器通过洪泛方式通告链路状态信息，获得全网拓扑。
使用Dijkstra算法计算最短路径，度量为“成本”。
收敛快，支持大规模网络和分层设计（区域Area），广泛应用于企业和运营商网络。


路由结构图与路由表的生成

距离向量协议通过邻居信息逐步更新路由表。
链路状态协议通过全网拓扑图计算最优路径，生成路由表。



3. BGP（边界网关协议）
BGP的功能

BGP（Border Gateway Protocol）是目前互联网中唯一广泛使用的EGP协议。
主要用于不同AS之间的路由信息交换，实现互联网范围的路由可达性和策略控制。
支持路由聚合、环路避免、策略过滤等高级功能。


BGP的基本报文类型和工作方式

报文类型：OPEN（建立连接）、UPDATE（通告路由）、KEEPALIVE（保持连接）、NOTIFICATION（错误通知）。
工作方式：
BGP路由器之间建立TCP连接，交换OPEN报文建立邻居关系。
通过UPDATE报文通告可达前缀和撤销路由。
定期发送KEEPALIVE报文保持连接。
支持路径向量机制，通过AS Path等属性避免环路。
支持灵活的路由策略和过滤，适应复杂的互联网环境。






总结：  

IGP（如RIP、OSPF）用于AS内部路由，侧重于快速收敛和最优路径选择。
EGP（主要是BGP）用于AS之间路由，侧重于策略控制和全网可达性。
路由表的生成方式和协议机制决定了网络的规模、收敛速度和灵活性。


可靠传输协议的设计要点可靠传输协议（如TCP）需要保证数据在不可靠信道上传输时的正确性、完整性和顺序。主要设计要点如下：

数据包损坏检测：校验和、ACK、NAK信号

校验和：每个数据包都带有校验和，接收方收到后进行校验，发现错误则丢弃。
ACK（确认）信号：接收方收到正确的数据包后，发送ACK确认给发送方。
NAK（否认）信号：接收方检测到数据包损坏时，发送NAK，通知发送方重传。


数据包丢失检测：超时计时器

发送方在发送数据包后启动超时计时器，若在规定时间内未收到ACK，则认为数据包丢失，自动重传。


按序交付、副本检测：序列号机制

每个数据包分配唯一的序列号，接收方根据序列号判断数据包顺序，保证按序交付。
序列号还能区分新旧数据，防止重复包被误收。
要求序列号空间足够大，以避免序列号回绕导致的混淆。


传输效率：流水线协议

为提高效率，采用流水线协议（如滑动窗口协议），允许发送方在未收到ACK前连续发送多个数据包，提高信道利用率。




总结：可靠传输协议通过校验和、ACK&#x2F;NAK、超时重传、序列号和流水线机制，确保数据可靠、有序、高效地传输到接收方。

流量控制流量控制用于防止发送方发送过快导致接收方缓存溢出，保证端到端通信的可靠性和高效性。主要机制包括：

滑动窗口机制的设计

滑动窗口是一种允许发送方在未收到ACK前可以连续发送多个数据包的机制。
发送窗口和接收窗口分别控制发送方和接收方的缓存和数据流动。
窗口的“滑动”表示随着ACK的到来，窗口范围向前移动，允许发送新的数据。


信用量窗口（Credit Window）

信用量窗口是接收方根据自身缓冲区剩余空间，动态告知发送方还能发送多少数据。
发送方根据接收方通告的窗口大小调整自己的发送速率，防止接收方溢出。


TCP复合的窗口管理方式

TCP流量控制采用滑动窗口和信用量窗口的结合。
发送方维护发送窗口，接收方通过ACK报文中的窗口字段（rwnd）通告剩余缓冲区大小。
发送方实际可发送的数据量受限于发送窗口、接收窗口和拥塞窗口三者的最小值。




连接维护TCP是面向连接的协议，连接的建立和终止都需要严格的握手过程，确保双方状态同步。

连接建立：三次握手

第一次：客户端发送SYN报文，发起连接请求。
第二次：服务器收到后，回复SYN+ACK报文，表示同意连接。
第三次：客户端收到SYN+ACK后，发送ACK报文，连接建立完成。
三次握手的必要性：防止历史失效连接请求影响当前连接，确保双方都具备发送和接收能力。


连接终止：四次挥手

第一次：主动关闭方发送FIN报文，表示无数据可发。
第二次：被动关闭方收到FIN后，回复ACK，表示收到终止请求。
第三次：被动关闭方处理完剩余数据后，发送FIN报文，表示同意关闭。
第四次：主动关闭方收到FIN后，回复ACK，连接彻底关闭。
四次挥手保证双方数据都能完整传输，避免数据丢失。




拥塞控制算法拥塞控制用于防止网络因过载而性能下降，TCP通过多种算法动态调整发送速率，主要内容如下：

时延RTT估计算法

RTT（Round Trip Time，往返时延）用于估算数据包从发送到收到ACK的时间。
TCP根据历史RTT测量值，采用加权平均等方法动态估算当前RTT，为超时重传和拥塞控制提供依据。


RTO计时器管理算法

RTO（Retransmission Timeout，重传超时时间）是TCP判断数据包丢失并触发重传的超时时间。
RTO根据RTT的估算值和波动性动态调整，防止过早或过晚重传。


Jacobson’s Reno算法（TCP Reno）

经典的TCP拥塞控制算法，包含以下机制：
慢启动（Slow Start）：初始拥塞窗口（cwnd）较小，每收到一个ACK，cwnd指数增长，快速探测可用带宽。
拥塞避免（AIMD）：窗口增长采用加性增大&#x2F;乘性减小（AIMD, Additive Increase Multiplicative Decrease）算法。正常时线性增长，发生丢包时窗口减半。
快重传（Fast Retransmit）：收到3个重复ACK时，立即重传丢失的数据包，无需等待超时。
快恢复（Fast Recovery）：丢包后窗口减半，不回到慢启动，维持较高的吞吐量。






总结：TCP通过RTT估计、RTO管理和Reno算法（慢启动、AIMD、快重传、快恢复）等机制，实现了高效、动态的拥塞控制，保证网络稳定和公平利用。
URL格式&lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;?query_string这个URL格式各部分的含义如下：

&lt;protocol&gt;：协议类型，如 http、https、ftp 等，指定访问资源所用的协议。
&lt;host&gt;：主机名或IP地址，表示服务器的地址。
&lt;port&gt;：端口号，指定服务器上用于该协议的端口（如http默认80，https默认443），可省略则用默认端口。
&lt;path&gt;：资源路径，表示服务器上具体的文件或资源位置。
?query_string：查询字符串，通常用于传递参数给服务器，格式为 key1&#x3D;value1&amp;key2&#x3D;value2。

举例说明：
https://www.example.com:8080/index.html?name=alice&amp;id=123

https：协议
www.example.com：主机
8080：端口
/index.html：路径
?name=alice&amp;id=123：查询参数

http无状态的优缺点这张图讲的是HTTP是无状态协议（stateless），即每个请求-响应都是独立的，服务器不需要保存客户端的状态。

优点（Good）：

提高服务器端的可扩展性（scalability）。
故障处理更简单。
能处理更高的请求速率。
请求顺序无关紧要。


缺点（Bad）：

某些应用需要持久状态（persistent state），比如需要唯一标识用户或保存临时信息。
典型场景：购物车、用户资料、使用跟踪等。



总结：HTTP无状态带来扩展性和简化管理，但对于需要记住用户状态的应用（如购物车），就需要额外机制（如cookie）来实现状态保持。
cookies的作用Cookies 主要用来解决HTTP协议无状态的问题。
HTTP协议本身是无状态的，即服务器无法区分同一个用户的多次请求。Cookies 通过在客户端（浏览器）保存少量数据，并在每次请求时自动携带这些数据，实现了“会话跟踪”和“用户识别”。
主要用途：

记录用户登录状态（如免登录、购物车等）
识别和跟踪用户（如个性化设置、广告推荐）
实现会话管理（如区分不同用户的访问）

总结：Cookies 让服务器能够识别同一个用户的多次访问，实现用户状态的保持和个性化服务。

DNS系统的三大核心知识点
层次域名空间

DNS采用树状的层次结构进行域名管理，从根域（.）开始，向下分为顶级域（如.com、.cn）、二级域（如example.com）、三级域（如www.example.com）等。
每一级域名由点号分隔，层次结构便于分布式管理和扩展。
域名空间的分层设计，使得全球范围内的域名可以高效、唯一地分配和解析。


域名服务器

DNS系统由多种类型的服务器组成，包括：
根域名服务器（Root DNS Server）：位于域名空间的最顶层，负责管理顶级域的指向。
顶级域名服务器（TLD DNS Server）：管理如.com、.cn等顶级域下的域名。
权威域名服务器（Authoritative DNS Server）：负责某一具体域名的最终解析结果，存储该域名的真实IP地址。
本地域名服务器（Local&#x2F;Resolver DNS Server）：通常由ISP或企业提供，负责接收用户的DNS查询请求，并递归或迭代地向其他DNS服务器查询结果。


各类服务器协作，实现分布式、高可用的域名解析服务。


域名解析过程

域名解析是将用户输入的域名（如www.example.com）转换为对应IP地址的过程，主要包括以下步骤：
用户主机向本地域名服务器发起DNS查询请求。
本地域名服务器若缓存中无结果，则递归或迭代查询根服务器、顶级域服务器、权威服务器。
查询过程可能涉及多级跳转，最终获得目标域名的IP地址。
本地域名服务器将结果返回给用户主机，并缓存结果以加速后续查询。


域名解析过程支持递归查询（由本地服务器全权负责）和迭代查询（每级服务器只告诉下一级的地址）。



总结：

DNS系统通过层次化的命名空间、分布式的服务器体系和高效的解析流程，实现了域名到IP地址的高效映射，是互联网正常访问的基础。

ECN 🆚 TCPECN（Explicit Congestion Notification，显式拥塞通知）是一种网络拥塞控制机制，允许路由器在发生拥塞时，不丢弃数据包，而是在IP头部设置ECN标志，通知接收方发生了拥塞。接收方收到后，反馈给发送方，发送方据此降低发送速率。
TCP拥塞控制与ECN的优缺点比较：

传统TCP拥塞控制（如丢包检测）

优点：实现简单，无需网络设备支持，兼容性好。
缺点：只能通过丢包感知拥塞，导致不必要的数据包丢失和重传，增加延迟和网络负载。


ECN

优点：无需丢包即可感知拥塞，减少重传和延迟，提高网络性能和吞吐量。
缺点：需要端到端（主机和路由器）都支持ECN，部署成本较高，部分老旧设备不兼容。



总结：ECN通过显式标记通知拥塞，能更高效、低损地进行拥塞控制，但需要全网支持；传统TCP通过丢包感知拥塞，简单但效率低。

感谢阅读！如果这篇文章对你有帮助，欢迎点赞和分享。
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>my first address</title>
    <url>/2025/02/28/hello-world/</url>
    <content><![CDATA[this is my first articletest文件，梦开始的地方
]]></content>
  </entry>
  <entry>
    <title>域名解析与网站绑定完全指南</title>
    <url>/2025/08/15/%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BD%91%E7%AB%99%E7%BB%91%E5%AE%9A%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[域名解析与网站绑定完全指南🌐 前言当我们在浏览器输入 summer-flower.com 时，为什么能访问到我们的网站？这背后涉及了复杂的域名解析系统。本文将从零开始，详细解释域名解析的工作原理，以及如何将自定义域名绑定到 GitHub Pages。
📚 基础概念什么是域名？域名（Domain Name）是互联网上网站的人类可读地址，例如：

google.com
github.com 
summer-flower.com

它的作用是将复杂的IP地址（如 185.199.108.153）转换为容易记忆的名称。
什么是DNS？DNS（Domain Name System，域名系统）是互联网的”电话簿”，负责将域名翻译成IP地址。
DNS解析过程：用户输入: summer-flower.com    ↓DNS查询: summer-flower.com 对应哪个IP？    ↓  DNS返回: 185.199.108.153    ↓浏览器访问: 185.199.108.153    ↓服务器返回: 网站内容

🔧 DNS记录类型详解1. A记录（Address Record）作用: 将域名直接指向IPv4地址
格式: 域名 → IP地址
示例:
summer-flower.com → 185.199.108.153

使用场景: 

将域名指向网站服务器
最常用的记录类型
一个域名可以有多个A记录（负载均衡）

2. CNAME记录（Canonical Name Record）作用: 将域名指向另一个域名
格式: 域名 → 另一个域名
示例:
www.summer-flower.com → summer-flower.comblog.summer-flower.com → summer-flower.com

使用场景:

子域名重定向
CDN配置
服务别名

重要限制: 

根域名（如 summer-flower.com）不能使用CNAME
一个域名不能同时有CNAME和其他记录

3. NS记录（Name Server Record）作用: 指定域名的DNS服务器
格式: 域名 → DNS服务器地址
示例:
summer-flower.com → ns1.huaweicloud-dns.orgsummer-flower.com → ns2.huaweicloud-dns.org

使用场景:

域名注册商设置
DNS服务器迁移

4. SOA记录（Start of Authority Record）作用: 定义域名的权威信息
包含信息:

主DNS服务器
域名管理员邮箱
序列号
刷新时间
重试时间

使用场景:

系统自动创建
DNS同步控制

5. MX记录（Mail Exchange Record）作用: 指定邮件服务器
示例:
summer-flower.com → mail.summer-flower.com

6. TXT记录（Text Record）作用: 存储文本信息
使用场景:

域名验证
SPF邮件验证
网站验证

🌍 DNS解析的完整流程1. 浏览器发起请求用户输入: https://summer-flower.com

2. 本地DNS缓存检查检查顺序:1. 浏览器缓存2. 操作系统缓存3. 路由器缓存

3. 递归DNS查询本地DNS服务器 → 根DNS服务器根DNS服务器 → .com顶级域DNS服务器  .com DNS服务器 → summer-flower.com权威DNS服务器权威DNS服务器 → 返回IP地址

4. 返回结果并缓存IP地址 → 本地DNS服务器 → 用户设备同时: 各级缓存存储结果

🚀 GitHub Pages 域名绑定详解GitHub Pages 的工作原理默认访问方式:
https://用户名.github.io/仓库名例如: https://231220075.github.io

自定义域名访问:
https://your-domain.com例如: https://summer-flower.com

绑定步骤详解步骤1: 创建CNAME文件位置: /source/CNAME（对于Hexo）
内容:
summer-flower.com

作用:

告诉GitHub Pages你的自定义域名
触发GitHub生成SSL证书
启用域名重定向

步骤2: 配置DNS记录GitHub Pages IP地址:
185.199.108.153185.199.109.153185.199.110.153  185.199.111.153

DNS配置:
类型: A主机记录: @ 或 *记录值: 185.199.108.153TTL: 300

重复添加其他3个IP地址
步骤3: 等待生效时间线:
DNS配置 → 5-30分钟 → DNS传播完成DNS传播完成 → 10-15分钟 → GitHub检测到GitHub检测到 → 5-10分钟 → SSL证书生成SSL证书生成 → 网站完全可用

GitHub Pages 的验证机制DNS检查过程1. GitHub定期查询你的域名2. 检查是否指向GitHub Pages IP3. 验证CNAME文件内容4. 生成SSL证书5. 启用HTTPS访问

状态变化🔴 DNS check unsuccessful   ↓ (DNS生效)🟡 DNS check in progress   ↓ (验证完成)🟢 DNS configuration successful     ↓ (SSL生成)✅ Enforce HTTPS 可用

⚠️ 常见问题与解决方案问题1: DNS检查失败症状:
DNS check unsuccessfulDomain does not resolve to the GitHub Pages server

原因:

DNS记录配置错误
DNS还未传播完成
存在冲突记录

解决方案:
# 检查DNS是否生效dig your-domain.com# 期望结果: 4个A记录指向GitHub Pages

问题2: CNAME和A记录冲突错误配置:
summer-flower.com → CNAME → other-domain.com (错误)summer-flower.com → A → 185.199.108.153 (正确)

解决方案: 删除CNAME记录，只保留A记录
问题3: www子域名配置方案A: 使用泛域名解析
*.summer-flower.com → A → GitHub Pages IP

方案B: 单独配置CNAME
www.summer-flower.com → CNAME → summer-flower.com

问题4: SSL证书问题常见原因:

DNS配置不正确
GitHub还在验证过程中
域名验证失败

解决方案:

等待DNS完全传播
确保CNAME文件正确
检查GitHub Pages设置

🛠️ 实际操作示例华为云DNS配置登录控制台:
华为云控制台 → 域名与网站 → 云解析服务

添加记录:
记录类型: A主机记录: * (泛域名) 或 @ (根域名)线路类型: 全网默认TTL: 300记录值: 185.199.108.153

重复添加其他GitHub Pages IP
验证配置命令行验证:
# 检查DNS解析dig summer-flower.com# 检查网站访问curl -I https://summer-flower.com# 检查SSL证书curl -I https://summer-flower.com | grep -i server

在线工具验证:

DNS传播检查: https://www.whatsmydns.net/
SSL证书检查: https://www.ssllabs.com/ssltest/

📊 性能优化建议TTL设置优化开发阶段:
TTL: 300 (5分钟) - 便于快速测试

生产环境:
TTL: 3600 (1小时) - 减少DNS查询

多IP配置的好处负载均衡:

分散访问压力
提高可用性

容错机制:

某个IP故障时自动切换
提高网站稳定性

CDN集成CloudFlare示例:
域名 → CloudFlare → GitHub Pages

优势:

全球加速
DDoS防护
高级SSL功能

🔒 安全考虑HTTPS强制GitHub Pages设置:
Settings → Pages → Enforce HTTPS ✓

好处:

数据传输加密
SEO优势
现代浏览器要求

DNS安全DNSSEC:

防止DNS劫持
验证DNS响应真实性

私有DNS:

使用可信DNS服务器
避免DNS污染

📈 监控与维护监控指标可用性监控:

网站响应时间
DNS解析时间
SSL证书到期时间

工具推荐:

UptimeRobot（免费）
Pingdom（付费）
CloudFlare Analytics

维护任务定期检查:

DNS记录是否正确
SSL证书是否有效
网站访问是否正常

备份策略:

DNS配置备份
域名转移码保存
重要文件备份

🎯 总结域名解析是现代互联网的基础设施，理解其工作原理对于网站管理至关重要：
关键要点
DNS记录类型: A记录指向IP，CNAME指向域名
GitHub Pages绑定: 需要正确的DNS配置和CNAME文件
传播时间: DNS更改需要5-60分钟生效
安全性: 启用HTTPS和DNSSEC保护
监控: 持续监控确保服务稳定

最佳实践
使用A记录指向GitHub Pages IP
避免不必要的CNAME记录
设置合适的TTL值
启用HTTPS强制
定期监控和维护

通过本文的学习，相信你已经对域名解析有了全面的理解。在实际操作中，记住耐心等待DNS传播，遇到问题时系统性地排查，大部分问题都能迎刃而解。

相关资源:

GitHub Pages 官方文档
DNS 基础知识
华为云 DNS 使用指南

祝你的网站部署顺利！🚀
]]></content>
      <categories>
        <category>技术学习</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
        <tag>GitHub Pages</tag>
        <tag>网站部署</tag>
      </tags>
  </entry>
  <entry>
    <title>云原生结课project</title>
    <url>/2025/08/12/%E4%BA%91%E5%8E%9F%E7%94%9F%E7%BB%93%E8%AF%BEproject/</url>
    <content><![CDATA[📝 云原生结课project
顺手上传暑课项目

1. 项目组员信息


姓名
学号
个人贡献



黄睿智
231220075
part3 + 文档编写


白子敬
231220077
part1


陈翔宇
231220088
part2



2. 限流功能相关的关键代码和说明2.1 限流系统架构概述本项目采用基于 Bucket4j + Redis 的分布式限流方案，实现了多层次的流量控制机制：

应用层限流：使用 Bucket4j 令牌桶算法
连接层限流：Spring Boot Tomcat 连接池限制
网络层限流：Kubernetes 网络策略和端口转发限制

2.2 核心限流组件限流配置类 (RateLimitConfig.java)@Configurationpublic class RedisConfig &#123;        @Value(&quot;$&#123;REDIS_HOST:$&#123;spring.redis.host:localhost&#125;&#125;&quot;)    private String redisHost;        @Value(&quot;$&#123;REDIS_PORT:$&#123;spring.redis.port:6379&#125;&#125;&quot;)    private int redisPort;        @Bean    @Primary    public RedisConnectionFactory redisConnectionFactory() &#123;        // 直接从环境变量读取        String host = System.getenv(&quot;REDIS_HOST&quot;);        if (host == null || host.trim().isEmpty()) &#123;            host = redisHost;        &#125;                String portStr = System.getenv(&quot;REDIS_PORT&quot;);        int port = redisPort;        if (portStr != null &amp;&amp; !portStr.trim().isEmpty()) &#123;            try &#123;                port = Integer.parseInt(portStr);            &#125; catch (NumberFormatException e) &#123;                // 使用默认端口            &#125;        &#125;                System.out.println(&quot;Spring Data Redis connecting to: &quot; + host + &quot;:&quot; + port);                RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();        config.setHostName(host);        config.setPort(port);                JedisConnectionFactory factory = new JedisConnectionFactory(config);        return factory;    &#125;        @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(connectionFactory);        return template;    &#125;        @Bean    public JedisPool jedisPool() &#123;        // 直接从环境变量读取，如果为空则使用配置文件        String host = System.getenv(&quot;REDIS_HOST&quot;);        if (host == null || host.trim().isEmpty()) &#123;            host = redisHost;        &#125;                String portStr = System.getenv(&quot;REDIS_PORT&quot;);        int port = redisPort;        if (portStr != null &amp;&amp; !portStr.trim().isEmpty()) &#123;            try &#123;                port = Integer.parseInt(portStr);            &#125; catch (NumberFormatException e) &#123;                // 使用默认端口            &#125;        &#125;                System.out.println(&quot;Jedis Pool connecting to: &quot; + host + &quot;:&quot; + port);                JedisPoolConfig config = new JedisPoolConfig();        config.setMaxTotal(8);        config.setMaxIdle(8);        config.setMinIdle(0);        config.setTestOnBorrow(true);        config.setTestOnReturn(true);        config.setTestWhileIdle(true);        return new JedisPool(config, host, port);    &#125;&#125;

限流服务类 (RateLimiterService.java)@Servicepublic class RateLimiterService &#123;    private final ProxyManager&lt;byte[]&gt; buckets;    private static final byte[] KEY = &quot;global-rate-limit-key&quot;.getBytes();    @Autowired    public RateLimiterService(ProxyManager&lt;byte[]&gt; buckets) &#123;        this.buckets = buckets;    &#125;    public Bucket resolveBucket() &#123;        return buckets.builder().build(KEY, getConfigSupplier());    &#125;    private Supplier&lt;BucketConfiguration&gt; getConfigSupplier() &#123;        return () -&gt; BucketConfiguration.builder()                .addLimit(Bandwidth.classic(                    100,                     Refill.greedy(100, Duration.ofSeconds(1)))                )                .build();    &#125;&#125;

限流拦截器 (RateLimitInterceptor.java)@Componentpublic class RateLimitInterceptor implements HandlerInterceptor &#123;    @Autowired    private RateLimiterService rateLimiterService;    @Override    public boolean preHandle(HttpServletRequest request,                             HttpServletResponse response,                             Object handler) throws Exception &#123;        Bucket bucket = rateLimiterService.resolveBucket();        if (bucket.tryConsume(1)) &#123;            return true;        &#125; else &#123;            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());            response.getWriter().write(&quot;Too many requests&quot;);            return false;        &#125;    &#125;&#125;

Web 配置类 (WebMvcConfig.java)@Configurationpublic class WebMvcConfig implements WebMvcConfigurer &#123;    @Autowired    private RateLimitInterceptor rateLimitInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        // 注册限流拦截器并指定拦截路径        registry.addInterceptor(rateLimitInterceptor)                .addPathPatterns(&quot;/hello&quot;)  // 只拦截/hello路径                .order(0);    &#125;&#125;

2.3 应用配置application.properties 限流相关配置spring.application.name=prometheus-test-demo# 统一使用8998端口server.port=8998# Redis 配置 - 直接使用环境变量spring.redis.host=$&#123;REDIS_HOST:localhost&#125;spring.redis.port=$&#123;REDIS_PORT:6379&#125;spring.redis.timeout=2000ms# 强制使用 Jedis 客户端spring.redis.jedis.pool.enabled=truespring.redis.lettuce.pool.enabled=false# Actuator 配置management.endpoints.web.exposure.include=health,info,prometheus,metricsmanagement.endpoint.health.show-details=always# 限流相关配置rate.limit.enabled=truerate.limit.global.key=global-rate-limit-keyrate.limit.capacity=100rate.limit.refill.tokens=100rate.limit.refill.period=1s

2.4 限流工作流程用户请求 → Spring MVC → RateLimitInterceptor → RateLimiterService                                ↓                          检查 Redis 令牌桶                                ↓                    有令牌？─── YES ──→ 继续处理 → HelloController                        │                        NO                        ↓                  返回 HTTP 429 错误

2.5 限流算法说明令牌桶算法 (Token Bucket Algorithm)：

初始化：创建容量为100的令牌桶
令牌补充：每秒向桶中添加100个令牌
请求处理：每个请求尝试消费1个令牌
限流判断：
有令牌：允许请求，消费令牌
无令牌：拒绝请求，返回429状态码




3. Dockerfile及K8s 编排文件3.1 Dockerfile# 第一阶段：构建阶段 - 统一使用Java 11FROM maven:3.9.6-eclipse-temurin-17 AS builder# 设置工作目录WORKDIR /usr/src/mymaven# 复制 Maven 配置文件RUN mkdir -p /root/.m2COPY settings.xml /root/.m2/settings.xml# 复制pom.xml和源代码COPY pom.xml .COPY src ./src# 构建项目RUN mvn -B  clean package# 第二阶段：运行阶段FROM eclipse-temurin:17-jre-centos7# 设置时区RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimeRUN echo &#x27;Asia/Shanghai&#x27; &gt;/etc/timezone# 设置环境变量ENV JAVA_OPTS &#x27;&#x27;# 设置工作目录WORKDIR /app# 从构建阶段复制构建结果COPY --from=builder /usr/src/mymaven/target/prometheus-test-demo-0.0.1-SNAPSHOT.jar ./prometheus-test-demo-0.0.1-SNAPSHOT.jar# 启动命令 - 使用Java 11兼容的JVM参数ENTRYPOINT [&quot;sh&quot;, &quot;-c&quot;, &quot;set -e &amp;&amp; java -XX:+PrintFlagsFinal \                                           -XX:+HeapDumpOnOutOfMemoryError \                                           -XX:HeapDumpPath=/heapdump/heapdump.hprof \                                           -XX:+UseContainerSupport \                                           -XX:MaxRAMPercentage=75.0 \                                           -Djava.security.egd=file:/dev/./urandom \                                           $JAVA_OPTS -jar prometheus-test-demo-0.0.1-SNAPSHOT.jar&quot;]

Dockerfile 设计说明：

构建项目时删去原demo的 -DskipTests 参数，直接运行测试样例，因此在 Jenkinsfile 中不再执行test。
下图为测试运行结果


3.2 Kubernetes 部署文件 (prometheus-test-demo.yaml)apiVersion: apps/v1kind: Deploymentmetadata:  labels:    app: prometheus-test-demo  name: prometheus-test-demo  namespace: &#123;NAMESPACE&#125;spec:  replicas: 1  selector:    matchLabels:      app: prometheus-test-demo  template:    metadata:      annotations:        prometheus.io/path: /actuator/prometheus        prometheus.io/port: &quot;8998&quot;        prometheus.io/scheme: http        prometheus.io/scrape: &quot;true&quot;      labels:        app: prometheus-test-demo    spec:      initContainers:      - name: wait-for-redis        ../photos/posts/yys/image: busybox:1.36        command: [&#x27;sh&#x27;, &#x27;-c&#x27;]        args:        - |          until nc -z redis-service 6379; do            echo &quot;Waiting for Redis to be ready...&quot;            sleep 2          done          echo &quot;Redis is ready!&quot;      containers:        - ../photos/posts/yys/image: 172.22.83.19:30003/nju08/prometheus-test-demo:&#123;VERSION&#125;          name: prometheus-test-demo          ports:          - containerPort: 8998          env:          - name: REDIS_HOST            value: &quot;redis-service&quot;          - name: REDIS_PORT            value: &quot;6379&quot;          resources:            requests:              memory: &quot;128Mi&quot;                  cpu: &quot;100m&quot;                    limits:              memory: &quot;512Mi&quot;                  cpu: &quot;500m&quot;                  livenessProbe:            httpGet:              path: /actuator/health              port: 8998            initialDelaySeconds: 120            periodSeconds: 30            timeoutSeconds: 10            failureThreshold: 3          readinessProbe:            httpGet:              path: /actuator/health              port: 8998            initialDelaySeconds: 90            periodSeconds: 10            timeoutSeconds: 5            failureThreshold: 5---apiVersion: apps/v1kind: Deploymentmetadata:  name: redis  namespace: &#123;NAMESPACE&#125;  labels:    app: redisspec:  replicas: 1  selector:    matchLabels:      app: redis  template:    metadata:      labels:        app: redis    spec:      containers:      - name: redis        ../photos/posts/yys/image: redis:7-alpine        ports:        - containerPort: 6379        resources:          requests:            memory: &quot;64Mi&quot;            cpu: &quot;50m&quot;          limits:            memory: &quot;128Mi&quot;            cpu: &quot;100m&quot;        args:        - redis-server        - --appendonly        - &quot;yes&quot;        volumeMounts:        - name: redis-data          mountPath: /data      volumes:      - name: redis-data        emptyDir: &#123;&#125;---apiVersion: v1kind: Servicemetadata:  name: redis-service  namespace: &#123;NAMESPACE&#125;  labels:    app: redisspec:  selector:    app: redis  ports:  - name: redis    port: 6379    targetPort: 6379  type: ClusterIP---apiVersion: v1kind: Servicemetadata:  name: prometheus-test-demo  labels:    app: prometheus-test-demo  namespace: &#123;NAMESPACE&#125;spec:  type: NodePort  selector:    app: prometheus-test-demo  ports:    - name: management-port      protocol: TCP      port: 8998      targetPort: 8998

K8s 配置说明：

使用 InitContainer 确保 Redis 先启动
配置了资源限制防止资源耗尽
设置了健康检查确保服务可用

3.3 ServiceMonitor 配置 (prometheus-test-serviceMonitor.yaml)apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata:  labels:    k8s-app: prometheus-test-demo  name: prometheus-test-demo  namespace: &#123;MONITOR_NAMESPACE&#125;spec:  endpoints:  - interval: 30s    port: tcp    path: /actuator/prometheus    scheme: &#x27;http&#x27;  selector:    matchLabels:      app: prometheus-test-demo  namespaceSelector:    matchNames:    - &#123;NAMESPACE&#125;


4. Jenkins 持续集成、持续部署、持续测试配置文件与说明4.1 Jenkinsfile 完整配置pipeline &#123;    agent none        // 环境变量管理    environment &#123;        HARBOR_REGISTRY = &#x27;172.22.83.19:30003&#x27;        IMAGE_NAME = &#x27;nju08/prometheus-test-demo&#x27;        GIT_REPO = &#x27;https://gitee.com/grissom_sh/prometheus-test-demo.git&#x27;        NAMESPACE = &#x27;nju08&#x27;        MONITOR_NAMESPACE = &#x27;nju08&#x27;        HARBOR_USER = &#x27;nju08&#x27;    &#125;        parameters &#123;        string(name: &#x27;HARBOR_PASS&#x27;, defaultValue: &#x27;&#x27;, description: &#x27;Harbor login password&#x27;)    &#125;        stages &#123;        stage(&#x27;Clone Code&#x27;) &#123;            agent &#123;                label &#x27;master&#x27;            &#125;            steps &#123;                echo &quot;1.Git Clone Code&quot;                script &#123;                    try &#123;                        git url: &quot;$&#123;env.GIT_REPO&#125;&quot;                    &#125; catch (Exception e) &#123;                        error &quot;Git clone failed: $&#123;e.getMessage()&#125;&quot;                    &#125;                &#125;            &#125;        &#125;                stage(&#x27;Image Build&#x27;) &#123;            agent &#123;                label &#x27;master&#x27;            &#125;            steps &#123;                echo &quot;2.Image Build Stage (包含 Maven 构建)&quot;                timeout(time: 30, unit: &#x27;MINUTES&#x27;) &#123;                    script &#123;                        retry(3) &#123;                            try &#123;                                // 使用 Dockerfile 多阶段构建，包含 Maven 构建和镜像构建                                sh &quot;docker build --cache-from $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:latest -t $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:$&#123;BUILD_NUMBER&#125; -t $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:latest .&quot;                            &#125; catch (Exception e) &#123;                                echo &quot;Docker build attempt failed: $&#123;e.getMessage()&#125;&quot;                                throw e                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        stage(&#x27;Push&#x27;) &#123;            agent &#123;                label &#x27;master&#x27;            &#125;            steps &#123;                echo &quot;3.Push Docker Image Stage&quot;                script &#123;                    try &#123;                        sh &quot;echo &#x27;$&#123;HARBOR_PASS&#125;&#x27; | docker login --username=$&#123;HARBOR_USER&#125; --password-stdin $&#123;env.HARBOR_REGISTRY&#125;&quot;                        sh &quot;docker push $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:$&#123;BUILD_NUMBER&#125;&quot;                        sh &quot;docker push $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:latest&quot;                    &#125; catch (Exception e) &#123;                        error &quot;Docker push failed: $&#123;e.getMessage()&#125;&quot;                    &#125;                &#125;            &#125;        &#125;                        stage(&#x27;Deploy to Kubernetes&#x27;) &#123;            agent &#123;                label &#x27;slave&#x27;            &#125;            steps &#123;                container(&#x27;jnlp-kubectl&#x27;) &#123;                    script &#123;                        stage(&#x27;Clone YAML&#x27;) &#123;                            echo &quot;4. Git Clone YAML To Slave&quot;                            try &#123;                                // 使用 checkout scm 获取当前流水线的源代码                                checkout scm                            &#125; catch (Exception e) &#123;                                error &quot;Git clone on slave failed: $&#123;e.getMessage()&#125;&quot;                            &#125;                        &#125;                                                stage(&#x27;Config YAML&#x27;) &#123;                            echo &quot;5. Change YAML File Stage&quot;                            sh &#x27;sed -i &quot;s/&#123;VERSION&#125;/$&#123;BUILD_NUMBER&#125;/g&quot; ./jenkins/scripts/prometheus-test-demo.yaml&#x27;                            sh &#x27;sed -i &quot;s/&#123;NAMESPACE&#125;/$&#123;NAMESPACE&#125;/g&quot; ./jenkins/scripts/prometheus-test-demo.yaml&#x27;                            sh &#x27;sed -i &quot;s/&#123;MONITOR_NAMESPACE&#125;/$&#123;MONITOR_NAMESPACE&#125;/g&quot; ./jenkins/scripts/prometheus-test-serviceMonitor.yaml&#x27;                            sh &#x27;sed -i &quot;s/&#123;NAMESPACE&#125;/$&#123;NAMESPACE&#125;/g&quot; ./jenkins/scripts/prometheus-test-serviceMonitor.yaml&#x27;                            sh &#x27;cat ./jenkins/scripts/prometheus-test-demo.yaml&#x27;                            sh &#x27;cat ./jenkins/scripts/prometheus-test-serviceMonitor.yaml&#x27;                        &#125;                                                stage(&#x27;Deploy prometheus-test-demo&#x27;) &#123;                            echo &quot;6. Deploy To K8s Stage&quot;                            sh &#x27;kubectl apply -f ./jenkins/scripts/prometheus-test-demo.yaml&#x27;                        &#125;                                                stage(&#x27;Wait for Redis&#x27;) &#123;                            echo &quot;6.5. Wait for Redis to be ready&quot;                            try &#123;                                sh &quot;kubectl wait --for=condition=ready pod -l app=redis -n $&#123;NAMESPACE&#125; --timeout=120s&quot;                                echo &quot;Redis is ready!&quot;                            &#125; catch (Exception e) &#123;                                echo &quot;Redis readiness check failed, but continuing: $&#123;e.getMessage()&#125;&quot;                            &#125;                        &#125;                                                stage(&#x27;Deploy prometheus-test-demo ServiceMonitor&#x27;) &#123;                            echo &quot;7. Deploy ServiceMonitor To K8s Stage&quot;                            try &#123;                                sh &#x27;kubectl apply -f ./jenkins/scripts/prometheus-test-serviceMonitor.yaml&#x27;                            &#125; catch (Exception e) &#123;                                error &quot;ServiceMonitor deployment failed: $&#123;e.getMessage()&#125;&quot;                            &#125;                        &#125;                                                stage(&#x27;Health Check&#x27;) &#123;                            echo &quot;8. Health Check Stage&quot;                            try &#123;                                sh &quot;kubectl wait --for=condition=ready pod -l app=prometheus-test-demo -n $&#123;NAMESPACE&#125; --timeout=300s&quot;                                echo &quot;Application is healthy and ready!&quot;                            &#125; catch (Exception e) &#123;                                error &quot;Health check failed: $&#123;e.getMessage()&#125;&quot;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;        // 通知机制和清理    post &#123;        success &#123;            echo &#x27;🎉 Pipeline succeeded! Application deployed successfully.&#x27;            script &#123;                echo &quot;✅ Deployment Summary:&quot;                echo &quot;   - Image: $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:$&#123;BUILD_NUMBER&#125;&quot;                echo &quot;   - Namespace: $&#123;NAMESPACE&#125;&quot;                echo &quot;   - Monitor Namespace: $&#123;MONITOR_NAMESPACE&#125;&quot;            &#125;        &#125;        failure &#123;            echo &#x27;❌ Pipeline failed! Please check the logs for details.&#x27;        &#125;        always &#123;            echo &#x27;🔄 Pipeline execution completed.&#x27;            // 清理本地镜像以节省磁盘空间            script &#123;                try &#123;                    sh &quot;docker rmi $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:$&#123;BUILD_NUMBER&#125; || true&quot;                    sh &quot;docker rmi $&#123;env.HARBOR_REGISTRY&#125;/$&#123;env.IMAGE_NAME&#125;:latest || true&quot;                    sh &quot;docker system prune -f || true&quot;                &#125; catch (Exception e) &#123;                    echo &quot;Image cleanup failed: $&#123;e.getMessage()&#125;&quot;                &#125;            &#125;        &#125;    &#125;&#125;

4.2 Jenkins 流水线说明流水线各阶段详解：

Checkout 阶段：

拉取源代码
生成构建版本号


Build 阶段：

Maven 编译和测试
生成构建产物


Docker Build &amp; Push 阶段：

构建容器镜像
推送到镜像仓库


Deploy to Kubernetes 阶段：

配置 K8s 部署文件
部署应用和依赖服务
健康检查



4.3 CI&#x2F;CD 流程验证截图位置镜像构建截图：
构建成功截图：
部署成功截图：

5. 监控指标采集的配置及说明；Grafana 监控大屏截图5.1 Prometheus 监控配置5.1.1 应用监控注解配置应用 Pod 配置了 Prometheus 自动发现注解：
annotations:  prometheus.io/path: /actuator/prometheus    # 指标采集路径  prometheus.io/port: &quot;8998&quot;                  # 监控端口  prometheus.io/scheme: http                  # 协议  prometheus.io/scrape: &quot;true&quot;               # 启用自动发现

5.1.2 ServiceMonitor 配置apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata:  labels:    k8s-app: prometheus-test-demo  name: prometheus-test-demo  namespace: &#123;MONITOR_NAMESPACE&#125;spec:  endpoints:  - interval: 30s    port: tcp    path: /actuator/prometheus    scheme: &#x27;http&#x27;  selector:    matchLabels:      app: prometheus-test-demo  namespaceSelector:    matchNames:    - &#123;NAMESPACE&#125;

5.2 关键监控指标5.2.1 应用性能指标
HTTP 请求指标：

http_server_requests_seconds_count - 请求总数
http_server_requests_seconds_sum - 请求总耗时
http_server_requests_seconds_max - 最大响应时间


JVM 指标：

jvm_memory_used_bytes - JVM 内存使用
jvm_gc_pause_seconds - GC 暂停时间
jvm_threads_live_threads - 活跃线程数



5.2.2 限流相关指标
Bucket4j 指标（如果配置了 Micrometer 集成）：

bucket4j_consumed_tokens_total - 消费的令牌总数
bucket4j_rejected_requests_total - 被拒绝的请求数
bucket4j_available_tokens - 可用令牌数


Tomcat 连接池指标：

tomcat_sessions_active_current - 活跃会话数
tomcat_threads_busy_threads - 繁忙线程数
tomcat_threads_config_max_threads - 最大线程数


指标监测：

端口转发之后 curl http://localhost:8998/actuator/prometheus，得到详细数据。

# HELP application_ready_time_seconds Time taken for the application to be ready to service requests# TYPE application_ready_time_seconds gaugeapplication_ready_time_seconds&#123;main_application_class=&quot;com.hello.hello.HelloApplication&quot;&#125; 47.994# HELP application_started_time_seconds Time taken to start the application# TYPE application_started_time_seconds gaugeapplication_started_time_seconds&#123;main_application_class=&quot;com.hello.hello.HelloApplication&quot;&#125; 47.787# HELP disk_free_bytes Usable space for path# TYPE disk_free_bytes gaugedisk_free_bytes&#123;path=&quot;/app/.&quot;&#125; 4.1373339648E10# HELP disk_total_bytes Total space for path# TYPE disk_total_bytes gaugedisk_total_bytes&#123;path=&quot;/app/.&quot;&#125; 5.36608768E10# HELP executor_active_threads The approximate number of threads that are actively executing tasks# TYPE executor_active_threads gaugeexecutor_active_threads&#123;name=&quot;applicationTaskExecutor&quot;&#125; 0.0# HELP executor_completed_tasks_total The approximate total number of tasks that have completed execution# TYPE executor_completed_tasks_total counterexecutor_completed_tasks_total&#123;name=&quot;applicationTaskExecutor&quot;&#125; 0.0# HELP executor_pool_core_threads The core number of threads for the pool# TYPE executor_pool_core_threads gaugeexecutor_pool_core_threads&#123;name=&quot;applicationTaskExecutor&quot;&#125; 8.0# HELP executor_pool_max_threads The maximum allowed number of threads in the pool# TYPE executor_pool_max_threads gaugeexecutor_pool_max_threads&#123;name=&quot;applicationTaskExecutor&quot;&#125; 2.147483647E9# HELP executor_pool_size_threads The current number of threads in the pool# TYPE executor_pool_size_threads gaugeexecutor_pool_size_threads&#123;name=&quot;applicationTaskExecutor&quot;&#125; 0.0# HELP executor_queue_remaining_tasks The number of additional elements that this queue can ideally accept without blocking# TYPE executor_queue_remaining_tasks gaugeexecutor_queue_remaining_tasks&#123;name=&quot;applicationTaskExecutor&quot;&#125; 2.147483647E9# HELP executor_queued_tasks The approximate number of tasks that are queued for execution# TYPE executor_queued_tasks gaugeexecutor_queued_tasks&#123;name=&quot;applicationTaskExecutor&quot;&#125; 0.0# HELP http_server_requests_active_seconds  # TYPE http_server_requests_active_seconds summaryhttp_server_requests_active_seconds_count&#123;exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;UNKNOWN&quot;&#125; 1http_server_requests_active_seconds_sum&#123;exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;UNKNOWN&quot;&#125; 0.194124977# HELP http_server_requests_active_seconds_max  # TYPE http_server_requests_active_seconds_max gaugehttp_server_requests_active_seconds_max&#123;exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;UNKNOWN&quot;&#125; 0.262306658# HELP http_server_requests_seconds  # TYPE http_server_requests_seconds summaryhttp_server_requests_seconds_count&#123;error=&quot;IOException&quot;,exception=&quot;IOException&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 77http_server_requests_seconds_sum&#123;error=&quot;IOException&quot;,exception=&quot;IOException&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 588.946979862http_server_requests_seconds_count&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/health&quot;&#125; 1314http_server_requests_seconds_sum&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/health&quot;&#125; 8.224338786http_server_requests_seconds_count&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 4708http_server_requests_seconds_sum&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 15666.990410086# HELP http_server_requests_seconds_max  # TYPE http_server_requests_seconds_max gaugehttp_server_requests_seconds_max&#123;error=&quot;IOException&quot;,exception=&quot;IOException&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 0.0http_server_requests_seconds_max&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/actuator/health&quot;&#125; 0.003561359http_server_requests_seconds_max&#123;error=&quot;none&quot;,exception=&quot;none&quot;,method=&quot;GET&quot;,outcome=&quot;SUCCESS&quot;,status=&quot;200&quot;,uri=&quot;/hello&quot;&#125; 0.0# HELP jvm_info JVM version info# TYPE jvm_info gaugejvm_info&#123;runtime=&quot;OpenJDK Runtime Environment&quot;,vendor=&quot;Eclipse Adoptium&quot;,version=&quot;17.0.11+9&quot;&#125; 1# HELP jvm_buffer_count_buffers An estimate of the number of buffers in the pool# TYPE jvm_buffer_count_buffers gaugejvm_buffer_count_buffers&#123;id=&quot;direct&quot;&#125; 12.0jvm_buffer_count_buffers&#123;id=&quot;mapped&quot;&#125; 0.0jvm_buffer_count_buffers&#123;id=&quot;mapped - &#x27;non-volatile memory&#x27;&quot;&#125; 0.0# HELP jvm_buffer_memory_used_bytes An estimate of the memory that the Java virtual machine is using for this buffer pool# TYPE jvm_buffer_memory_used_bytes gaugejvm_buffer_memory_used_bytes&#123;id=&quot;direct&quot;&#125; 100352.0jvm_buffer_memory_used_bytes&#123;id=&quot;mapped&quot;&#125; 0.0jvm_buffer_memory_used_bytes&#123;id=&quot;mapped - &#x27;non-volatile memory&#x27;&quot;&#125; 0.0# HELP jvm_buffer_total_capacity_bytes An estimate of the total capacity of the buffers in this pool# TYPE jvm_buffer_total_capacity_bytes gaugejvm_buffer_total_capacity_bytes&#123;id=&quot;direct&quot;&#125; 100352.0jvm_buffer_total_capacity_bytes&#123;id=&quot;mapped&quot;&#125; 0.0jvm_buffer_total_capacity_bytes&#123;id=&quot;mapped - &#x27;non-volatile memory&#x27;&quot;&#125; 0.0# HELP jvm_classes_loaded_classes The number of classes that are currently loaded in the Java virtual machine# TYPE jvm_classes_loaded_classes gaugejvm_classes_loaded_classes 10568.0# HELP jvm_classes_unloaded_classes_total The number of classes unloaded in the Java virtual machine# TYPE jvm_classes_unloaded_classes_total counterjvm_classes_unloaded_classes_total 80.0# HELP jvm_compilation_time_ms_total The approximate accumulated elapsed time spent in compilation# TYPE jvm_compilation_time_ms_total counterjvm_compilation_time_ms_total&#123;compiler=&quot;HotSpot 64-Bit Tiered Compilers&quot;&#125; 218885.0# HELP jvm_gc_live_data_size_bytes Size of long-lived heap memory pool after reclamation# TYPE jvm_gc_live_data_size_bytes gaugejvm_gc_live_data_size_bytes 8.5416936E7# HELP jvm_gc_max_data_size_bytes Max size of long-lived heap memory pool# TYPE jvm_gc_max_data_size_bytes gaugejvm_gc_max_data_size_bytes 2.68435456E8# HELP jvm_gc_memory_allocated_bytes_total Incremented for an increase in the size of the (young) heap memory pool after one GC to before the next# TYPE jvm_gc_memory_allocated_bytes_total counterjvm_gc_memory_allocated_bytes_total 4.95829704E8# HELP jvm_gc_memory_promoted_bytes_total Count of positive increases in the size of the old generation memory pool before GC to after GC# TYPE jvm_gc_memory_promoted_bytes_total counterjvm_gc_memory_promoted_bytes_total 7.1289304E7# HELP jvm_gc_overhead An approximation of the percent of CPU time used by GC activities over the last lookback period or since monitoring began, whichever is shorter, in the range [0..1]# TYPE jvm_gc_overhead gaugejvm_gc_overhead 0.0# HELP jvm_gc_pause_seconds Time spent in GC pause# TYPE jvm_gc_pause_seconds summaryjvm_gc_pause_seconds_count&#123;action=&quot;end of major GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;MarkSweepCompact&quot;&#125; 3jvm_gc_pause_seconds_sum&#123;action=&quot;end of major GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;MarkSweepCompact&quot;&#125; 0.976jvm_gc_pause_seconds_count&#123;action=&quot;end of minor GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;Copy&quot;&#125; 16jvm_gc_pause_seconds_sum&#123;action=&quot;end of minor GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;Copy&quot;&#125; 1.047# HELP jvm_gc_pause_seconds_max Time spent in GC pause# TYPE jvm_gc_pause_seconds_max gaugejvm_gc_pause_seconds_max&#123;action=&quot;end of major GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;MarkSweepCompact&quot;&#125; 0.0jvm_gc_pause_seconds_max&#123;action=&quot;end of minor GC&quot;,cause=&quot;Allocation Failure&quot;,gc=&quot;Copy&quot;&#125; 0.0# HELP jvm_memory_committed_bytes The amount of memory in bytes that is committed for the Java virtual machine to use# TYPE jvm_memory_committed_bytes gaugejvm_memory_committed_bytes&#123;area=&quot;heap&quot;,id=&quot;Eden Space&quot;&#125; 5.7081856E7jvm_memory_committed_bytes&#123;area=&quot;heap&quot;,id=&quot;Survivor Space&quot;&#125; 7077888.0jvm_memory_committed_bytes&#123;area=&quot;heap&quot;,id=&quot;Tenured Gen&quot;&#125; 1.42364672E8jvm_memory_committed_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-nmethods&#x27;&quot;&#125; 2555904.0jvm_memory_committed_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-profiled nmethods&#x27;&quot;&#125; 5636096.0jvm_memory_committed_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;profiled nmethods&#x27;&quot;&#125; 1.572864E7jvm_memory_committed_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Compressed Class Space&quot;&#125; 6815744.0jvm_memory_committed_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Metaspace&quot;&#125; 5.1707904E7# HELP jvm_memory_max_bytes The maximum amount of memory in bytes that can be used for memory management# TYPE jvm_memory_max_bytes gaugejvm_memory_max_bytes&#123;area=&quot;heap&quot;,id=&quot;Eden Space&quot;&#125; 1.0747904E8jvm_memory_max_bytes&#123;area=&quot;heap&quot;,id=&quot;Survivor Space&quot;&#125; 1.3369344E7jvm_memory_max_bytes&#123;area=&quot;heap&quot;,id=&quot;Tenured Gen&quot;&#125; 2.68435456E8jvm_memory_max_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-nmethods&#x27;&quot;&#125; 5828608.0jvm_memory_max_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-profiled nmethods&#x27;&quot;&#125; 1.22916864E8jvm_memory_max_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;profiled nmethods&#x27;&quot;&#125; 1.22912768E8jvm_memory_max_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Compressed Class Space&quot;&#125; 1.073741824E9jvm_memory_max_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Metaspace&quot;&#125; -1.0# HELP jvm_memory_usage_after_gc The percentage of long-lived heap pool used after the last GC event, in the range [0..1]# TYPE jvm_memory_usage_after_gc gaugejvm_memory_usage_after_gc&#123;area=&quot;heap&quot;,pool=&quot;long-lived&quot;&#125; 0.3310730457305908# HELP jvm_memory_used_bytes The amount of used memory# TYPE jvm_memory_used_bytes gaugejvm_memory_used_bytes&#123;area=&quot;heap&quot;,id=&quot;Eden Space&quot;&#125; 3.3653184E7jvm_memory_used_bytes&#123;area=&quot;heap&quot;,id=&quot;Survivor Space&quot;&#125; 854168.0jvm_memory_used_bytes&#123;area=&quot;heap&quot;,id=&quot;Tenured Gen&quot;&#125; 8.8871744E7jvm_memory_used_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-nmethods&#x27;&quot;&#125; 1349248.0jvm_memory_used_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;non-profiled nmethods&#x27;&quot;&#125; 5586048.0jvm_memory_used_bytes&#123;area=&quot;nonheap&quot;,id=&quot;CodeHeap &#x27;profiled nmethods&#x27;&quot;&#125; 1.5632E7jvm_memory_used_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Compressed Class Space&quot;&#125; 6518344.0jvm_memory_used_bytes&#123;area=&quot;nonheap&quot;,id=&quot;Metaspace&quot;&#125; 5.1187048E7# HELP jvm_threads_daemon_threads The current number of live daemon threads# TYPE jvm_threads_daemon_threads gaugejvm_threads_daemon_threads 20.0# HELP jvm_threads_live_threads The current number of live threads including both daemon and non-daemon threads# TYPE jvm_threads_live_threads gaugejvm_threads_live_threads 24.0# HELP jvm_threads_peak_threads The peak live thread count since the Java virtual machine started or peak was reset# TYPE jvm_threads_peak_threads gaugejvm_threads_peak_threads 214.0# HELP jvm_threads_started_threads_total The total number of application threads started in the JVM# TYPE jvm_threads_started_threads_total counterjvm_threads_started_threads_total 249.0# HELP jvm_threads_states_threads The current number of threads# TYPE jvm_threads_states_threads gaugejvm_threads_states_threads&#123;state=&quot;blocked&quot;&#125; 0.0jvm_threads_states_threads&#123;state=&quot;new&quot;&#125; 0.0jvm_threads_states_threads&#123;state=&quot;runnable&quot;&#125; 7.0jvm_threads_states_threads&#123;state=&quot;terminated&quot;&#125; 0.0jvm_threads_states_threads&#123;state=&quot;timed-waiting&quot;&#125; 6.0jvm_threads_states_threads&#123;state=&quot;waiting&quot;&#125; 11.0# HELP logback_events_total Number of log events that were enabled by the effective log level# TYPE logback_events_total counterlogback_events_total&#123;level=&quot;debug&quot;&#125; 0.0logback_events_total&#123;level=&quot;error&quot;&#125; 0.0logback_events_total&#123;level=&quot;info&quot;&#125; 5.0logback_events_total&#123;level=&quot;trace&quot;&#125; 0.0logback_events_total&#123;level=&quot;warn&quot;&#125; 0.0# HELP process_cpu_time_ns_total The &quot;cpu time&quot; used by the Java Virtual Machine process# TYPE process_cpu_time_ns_total counterprocess_cpu_time_ns_total 1.0813E11# HELP process_cpu_usage The &quot;recent cpu usage&quot; for the Java Virtual Machine process# TYPE process_cpu_usage gaugeprocess_cpu_usage 0.09197856413746172# HELP process_files_max_files The maximum file descriptor count# TYPE process_files_max_files gaugeprocess_files_max_files 1048576.0# HELP process_files_open_files The open file descriptor count# TYPE process_files_open_files gaugeprocess_files_open_files 15.0# HELP process_start_time_seconds Start time of the process since unix epoch.# TYPE process_start_time_seconds gaugeprocess_start_time_seconds 1.752976768479E9# HELP process_uptime_seconds The uptime of the Java virtual machine# TYPE process_uptime_seconds gaugeprocess_uptime_seconds 9948.976# HELP system_cpu_count The number of processors available to the Java virtual machine# TYPE system_cpu_count gaugesystem_cpu_count 1.0# HELP system_cpu_usage The &quot;recent cpu usage&quot; of the system the application is running in# TYPE system_cpu_usage gaugesystem_cpu_usage 0.09208738261313372# HELP system_load_average_1m The sum of the number of runnable entities queued to available processors and the number of runnable entities running on the available processors averaged over a period of time# TYPE system_load_average_1m gaugesystem_load_average_1m 0.08# HELP tomcat_sessions_active_current_sessions  # TYPE tomcat_sessions_active_current_sessions gaugetomcat_sessions_active_current_sessions 0.0# HELP tomcat_sessions_active_max_sessions  # TYPE tomcat_sessions_active_max_sessions gaugetomcat_sessions_active_max_sessions 0.0# HELP tomcat_sessions_alive_max_seconds  # TYPE tomcat_sessions_alive_max_seconds gaugetomcat_sessions_alive_max_seconds 0.0# HELP tomcat_sessions_created_sessions_total  # TYPE tomcat_sessions_created_sessions_total countertomcat_sessions_created_sessions_total 0.0# HELP tomcat_sessions_expired_sessions_total  # TYPE tomcat_sessions_expired_sessions_total countertomcat_sessions_expired_sessions_total 0.0# HELP tomcat_sessions_rejected_sessions_total  # TYPE tomcat_sessions_rejected_sessions_total countertomcat_sessions_rejected_sessions_total 0.0

5.3 Grafana 监控大屏配置5.3.1 监控大屏概览本项目成功配置了多个 Grafana 监控大屏，涵盖了应用性能、网络流量和资源使用等关键指标：

SpringBoot APM Dashboard - 应用性能监控
Kubernetes &#x2F; Compute Resources &#x2F; Namespace - 集群资源监控  
网络流量监控面板 - Pod 间通信监控

5.3.2 SpringBoot APM Dashboard 配置面板配置说明：
&#123;  &quot;dashboard&quot;: &#123;    &quot;title&quot;: &quot;SpringBoot APM Dashboard&quot;,    &quot;panels&quot;: [      &#123;        &quot;title&quot;: &quot;Basic Statistics&quot;,        &quot;type&quot;: &quot;stat&quot;,        &quot;targets&quot;: [          &#123;            &quot;expr&quot;: &quot;process_uptime_seconds&#123;instance=~\&quot;.*prometheus-test-demo.*\&quot;&#125;&quot;,            &quot;legendFormat&quot;: &quot;Uptime&quot;          &#125;,          &#123;            &quot;expr&quot;: &quot;jvm_memory_used_bytes&#123;area=\&quot;heap\&quot;&#125;/jvm_memory_max_bytes&#123;area=\&quot;heap\&quot;&#125;*100&quot;,            &quot;legendFormat&quot;: &quot;Heap Used %&quot;          &#125;        ]      &#125;    ]  &#125;&#125;

关键监控指标：

运行时间: 1.5 天稳定运行
堆内存使用: 9.4% (健康水平)
非堆内存使用: 5.2% (正常状态)
CPU 使用率: 平均 0.577% (系统空闲)
负载均衡: 0.436 (轻负载)


5.3.3 Kubernetes 资源监控配置集群资源监控面板配置：
CPU 使用率监控：
# CPU 使用率 (基于请求)rate(container_cpu_usage_seconds_total&#123;namespace=&quot;nju08&quot;&#125;[5m]) * 100# CPU 使用率 (基于限制)  rate(container_cpu_usage_seconds_total&#123;namespace=&quot;nju08&quot;&#125;[5m]) / on(pod) kube_pod_container_resource_limits&#123;resource=&quot;cpu&quot;&#125; * 100

内存使用率监控：
# 内存使用率 (基于请求)container_memory_usage_bytes&#123;namespace=&quot;nju08&quot;&#125; / container_spec_memory_limit_bytes * 100# 内存使用率 (基于限制)container_memory_usage_bytes&#123;namespace=&quot;nju08&quot;&#125; / on(pod) kube_pod_container_resource_limits&#123;resource=&quot;memory&quot;&#125; * 100

监控数据分析：

CPU 使用率 (基于请求)
CPU 使用率 (基于限制) 
内存使用率 (基于请求) 
内存使用率 (基于限制)


5.3.4 网络流量监控配置网络监控面板配置：
接收&#x2F;发送字节数监控：
# 网络接收速率rate(container_network_receive_bytes_total&#123;namespace=&quot;nju08&quot;&#125;[5m])# 网络发送速率  rate(container_network_transmit_bytes_total&#123;namespace=&quot;nju08&quot;&#125;[5m])

网络包监控：
# 接收包速率rate(container_network_receive_packets_total&#123;namespace=&quot;nju08&quot;&#125;[5m])# 发送包速率rate(container_network_transmit_packets_total&#123;namespace=&quot;nju08&quot;&#125;[5m])# 丢包率rate(container_network_receive_packets_dropped_total&#123;namespace=&quot;nju08&quot;&#125;[5m])rate(container_network_transmit_packets_dropped_total&#123;namespace=&quot;nju08&quot;&#125;[5m])

网络流量分析：

峰值网络吞吐量: ~200 kB&#x2F;s (发送&#x2F;接收)
峰值包速率: ~2 kp&#x2F;s (接收&#x2F;发送)
网络活动时间: 05:30 左右出现流量峰值
丢包情况: 基本无丢包，网络稳定


5.3.5 压测时的监控表现压测期间关键指标变化：

CPU 使用率飙升：

压测前: ~0.003 (0.3%)
压测时: ~0.37 (37%)
增长倍数: 约 123 倍


网络流量激增：

正常时: 几乎无流量 (0-10 kB&#x2F;s)
压测时: 峰值 200 kB&#x2F;s
包速率: 峰值 2000 packets&#x2F;s


内存使用稳定：

内存使用率保持在合理范围
未出现内存泄漏现象



5.3.6 限流效果在监控中的体现限流监控配置：
# HTTP 请求速率rate(http_server_requests_seconds_count&#123;uri=&quot;/hello&quot;&#125;[1m]) * 60# 错误率 (限流触发)rate(http_server_requests_seconds_count&#123;exception=&quot;IOException&quot;&#125;[1m]) /rate(http_server_requests_seconds_count&#123;uri=&quot;/hello&quot;&#125;[1m]) * 100# 连接数监控tomcat_threads_busy_threads / tomcat_threads_config_max_threads * 100

限流效果观察：

✅ 流量控制有效: 网络流量在达到峰值后快速回落
✅ CPU 保护机制: CPU 使用率未超过危险阈值
✅ 连接层限流: 通过网络包丢弃实现早期限流


6. 压测6.1 压测工具6.1.1 基础压测脚本#!/bin/bashURL=&quot;http://localhost:8998/hello&quot;CONCURRENT=10REQUESTS=100echo &quot;Starting load test...&quot;echo &quot;URL: $URL&quot;echo &quot;Concurrent requests: $CONCURRENT&quot;echo &quot;Total requests: $REQUESTS&quot;for i in $(seq 1 $REQUESTS); do    (        response=$(curl -s -w &quot;%&#123;http_code&#125;,%&#123;time_total&#125;&quot; -o /dev/null $URL)        echo &quot;Request $i: $response&quot;    ) &amp;        # 控制并发数    if (( $i % $CONCURRENT == 0 )); then        wait    fidonewaitecho &quot;Load test completed!&quot;

6.1.2 高频限流测试脚本#!/bin/bash# 颜色定义RED=&#x27;\033[0;31m&#x27;GREEN=&#x27;\033[0;32m&#x27;YELLOW=&#x27;\033[1;33m&#x27;BLUE=&#x27;\033[0;34m&#x27;NC=&#x27;\033[0m&#x27; # No ColorURL=&quot;http://localhost:8998/hello&quot;NAMESPACE=&quot;nju08&quot;echo &quot;=========================================&quot;echo &quot;YYS 项目 - 超高频限流测试脚本&quot;echo &quot;=========================================&quot;# 检查端口转发check_port_forward() &#123;    if ! lsof -i :8998 &gt;/dev/null 2&gt;&amp;1; then        echo -e &quot;$&#123;RED&#125;❌ 端口转发未运行$&#123;NC&#125;&quot;        echo -e &quot;$&#123;YELLOW&#125;请先运行: kubectl port-forward deployment/prometheus-test-demo 8998:8998 -n $NAMESPACE$&#123;NC&#125;&quot;        exit 1    fi    echo -e &quot;$&#123;GREEN&#125;✅ 端口转发正常运行$&#123;NC&#125;&quot;&#125;# 多轮高频测试run_aggressive_test() &#123;    echo &quot;&quot;    echo -e &quot;$&#123;BLUE&#125;🔥 开始超高频限流测试...$&#123;NC&#125;&quot;    echo &quot;目标: 超过 100 requests/second 限制&quot;    echo &quot;&quot;        # 测试配置    local ROUNDS=3    local REQUESTS_PER_ROUND=150    local MAX_CONCURRENT=100        for round in $(seq 1 $ROUNDS); do        echo -e &quot;$&#123;YELLOW&#125;=== 第 $round 轮测试 ===$&#123;NC&#125;&quot;        echo &quot;发送 $REQUESTS_PER_ROUND 个请求，$MAX_CONCURRENT 并发&quot;                local success_count=0        local rate_limited_count=0        local error_count=0        local timeout_count=0                start_time=$(date +%s.%N)                # 创建临时文件        temp_file=&quot;/tmp/aggressive_test_$&#123;round&#125;_$$&quot;                # 极限并发发送        for i in $(seq 1 $REQUESTS_PER_ROUND); do            &#123;                response=$(timeout 2 curl -s -w &quot;%&#123;http_code&#125;&quot; -o /dev/null \                    --connect-timeout 0.3 \                    --max-time 1 \                    --retry 0 \                    --no-keepalive \                    $URL 2&gt;/dev/null)                                exit_code=$?                timestamp=$(date &#x27;+%H:%M:%S.%3N&#x27;)                                if [ $exit_code -eq 124 ]; then                    echo &quot;TIMEOUT,$timestamp&quot; &gt;&gt; $temp_file                elif [ $exit_code -ne 0 ] || [ -z &quot;$response&quot; ]; then                    echo &quot;CONNECTION_FAILED,$timestamp&quot; &gt;&gt; $temp_file                else                    echo &quot;$response,$timestamp&quot; &gt;&gt; $temp_file                fi            &#125; &amp;                        # 减少等待时间，增加并发密度            if (( $i % $MAX_CONCURRENT == 0 )); then                wait            fi        done                wait                end_time=$(date +%s.%N)        duration=$(echo &quot;$end_time - $start_time&quot; | bc 2&gt;/dev/null || echo &quot;1&quot;)        rate=$(echo &quot;scale=2; $REQUESTS_PER_ROUND / $duration&quot; | bc 2&gt;/dev/null || echo &quot;0&quot;)                echo &quot;  持续时间: $&#123;duration&#125;秒&quot;        echo &quot;  实际速率: $&#123;rate&#125; requests/second&quot;                # 统计结果        while IFS=&#x27;,&#x27; read -r status_or_error timestamp; do            case &quot;$status_or_error&quot; in                &quot;200&quot;) ((success_count++)) ;;                &quot;429&quot;|&quot;503&quot;)                     ((rate_limited_count++))                    echo -e &quot;  $&#123;YELLOW&#125;🚫 限流: $timestamp - HTTP $status_or_error$&#123;NC&#125;&quot;                    ;;                &quot;TIMEOUT&quot;)                     ((timeout_count++))                    echo -e &quot;  $&#123;RED&#125;⏰ 超时: $timestamp$&#123;NC&#125;&quot;                    ;;                &quot;CONNECTION_FAILED&quot;|*)                    ((error_count++))                    echo -e &quot;  $&#123;RED&#125;❌ 失败: $timestamp$&#123;NC&#125;&quot;                    ;;            esac        done &lt; $temp_file 2&gt;/dev/null                rm -f $temp_file                echo -e &quot;  结果: ✅$success_count 🚫$rate_limited_count ⏰$timeout_count ❌$error_count&quot;                if [ $rate_limited_count -gt 0 ] || [ $timeout_count -gt 5 ] || [ $error_count -gt 5 ]; then            echo -e &quot;  $&#123;GREEN&#125;🎯 第 $round 轮检测到限流效果!$&#123;NC&#125;&quot;        else            echo -e &quot;  $&#123;YELLOW&#125;⚠️  第 $round 轮未检测到限流$&#123;NC&#125;&quot;        fi                echo &quot;&quot;                # 轮次间短暂休息        if [ $round -lt $ROUNDS ]; then            sleep 1        fi    done&#125;# 连续轰炸测试run_continuous_bombardment() &#123;    echo -e &quot;$&#123;BLUE&#125;💥 连续轰炸测试 (30秒内持续发送请求)$&#123;NC&#125;&quot;    echo &quot;&quot;        local duration=30    local concurrent=50    local total_requests=0    local success_count=0    local limited_count=0        start_time=$(date +%s)    end_target=$((start_time + duration))        echo &quot;开始时间: $(date)&quot;    echo &quot;目标持续: $&#123;duration&#125;秒&quot;    echo &quot;并发数: $concurrent&quot;    echo &quot;&quot;        while [ $(date +%s) -lt $end_target ]; do        # 每次发送一批请求        for i in $(seq 1 $concurrent); do            &#123;                response=$(curl -s -w &quot;%&#123;http_code&#125;&quot; -o /dev/null \                    --connect-timeout 0.2 \                    --max-time 0.5 \                    $URL 2&gt;/dev/null)                                ((total_requests++))                                if [ &quot;$response&quot; = &quot;200&quot; ]; then                    ((success_count++))                elif [ &quot;$response&quot; = &quot;429&quot; ] || [ &quot;$response&quot; = &quot;503&quot; ]; then                    ((limited_count++))                    echo -e &quot;$&#123;YELLOW&#125;🚫 限流触发! HTTP $response at $(date &#x27;+%H:%M:%S&#x27;)$&#123;NC&#125;&quot;                fi            &#125; &amp;        done                # 短暂等待后继续        sleep 0.1    done        wait        actual_duration=$(($(date +%s) - start_time))    actual_rate=$(echo &quot;scale=2; $total_requests / $actual_duration&quot; | bc 2&gt;/dev/null || echo &quot;0&quot;)        echo &quot;&quot;    echo -e &quot;$&#123;BLUE&#125;💥 连续轰炸测试结果$&#123;NC&#125;&quot;    echo &quot;实际持续时间: $&#123;actual_duration&#125;秒&quot;    echo &quot;总请求数: $total_requests&quot;    echo &quot;平均速率: $&#123;actual_rate&#125; requests/second&quot;    echo &quot;成功请求: $success_count&quot;    echo &quot;限流触发: $limited_count&quot;        if [ $limited_count -gt 0 ]; then        echo -e &quot;$&#123;GREEN&#125;🎯 连续轰炸成功触发限流!$&#123;NC&#125;&quot;    else        echo -e &quot;$&#123;YELLOW&#125;⚠️  连续轰炸未触发限流$&#123;NC&#125;&quot;    fi&#125;# Apache Bench 测试 (如果可用)run_ab_test() &#123;    if command -v ab &amp;&gt; /dev/null; then        echo &quot;&quot;        echo -e &quot;$&#123;BLUE&#125;⚡ Apache Bench 高性能测试$&#123;NC&#125;&quot;        echo &quot;&quot;                echo &quot;测试1: 500个请求，200并发&quot;        ab -n 500 -c 200 $URL                echo &quot;&quot;        echo &quot;测试2: 2秒内尽可能多的请求，300并发&quot;        ab -t 2 -c 300 $URL            else        echo &quot;&quot;        echo -e &quot;$&#123;YELLOW&#125;💡 建议安装 Apache Bench 进行更高性能的测试:$&#123;NC&#125;&quot;        echo &quot;  sudo apt-get install apache2-utils&quot;        echo &quot;  然后运行: ab -n 1000 -c 300 $URL&quot;    fi&#125;# 检查限流配置check_rate_limit_config() &#123;    echo &quot;&quot;    echo -e &quot;$&#123;BLUE&#125;⚙️ 检查当前限流配置$&#123;NC&#125;&quot;        # 检查 Redis 中的令牌桶状态    echo &quot;Redis 限流键:&quot;    kubectl exec deployment/redis -n $NAMESPACE -- redis-cli keys &quot;*rate*&quot; 2&gt;/dev/null || echo &quot;无法访问Redis&quot;        # 尝试获取桶的状态 (这个可能需要特殊的命令)    echo &quot;&quot;    echo &quot;当前应用配置:&quot;    echo &quot;- 限流阈值: 100 requests/second&quot;    echo &quot;- 令牌桶容量: 100&quot;    echo &quot;- 补充速率: 100 tokens/second&quot;    echo &quot;- 限流键: global-rate-limit-key&quot;&#125;# 主执行流程main() &#123;    check_port_forward    check_rate_limit_config    run_aggressive_test    run_continuous_bombardment    run_ab_test        echo &quot;&quot;    echo -e &quot;$&#123;GREEN&#125;🏁 超高频限流测试完成!$&#123;NC&#125;&quot;&#125;# 执行主函数main &quot;$@&quot;





6.2 压测结果压测结果截图：

未触发限流：  
触发限流：    
其中在限流之后转发的进程这边显示如下信息，说明超出阈值的request直接在tcp层被拒绝。


HTTP 000 状态码说明：


状态码 000 表示连接在 TCP 层被拒绝
这证明了限流系统在连接层面起到了保护作用
比 HTTP 429 更早介入，资源保护更彻底

7. 项目总结与技术亮点7.1 技术架构亮点
多层限流防护：

应用层：Bucket4j 令牌桶算法精确控制
连接层：Tomcat 连接池快速保护
网络层：K8s 网络策略综合防护


分布式限流设计：

基于 Redis 的分布式令牌桶
支持水平扩展和高可用
保证多实例间限流一致性


云原生最佳实践：

容器化部署
K8s 声明式配置
微服务架构设计



7.2 监控与运维亮点
全方位监控：

应用性能监控 (APM)
基础设施监控
业务指标监控


自动化运维：

CI&#x2F;CD 流水线自动化
健康检查和自愈能力
可观测性最佳实践



7.3 压测验证成果
限流功能验证：

成功验证 100 req&#x2F;s 限流阈值
确认多层限流机制有效性
系统保护能力得到验证


扩容能力验证：

K8s 水平扩容功能正常
负载均衡分发有效
性能线性提升明显



7.4 项目创新点
连接层限流策略：

在 TCP 连接层就实现流量控制
比传统 HTTP 层限流更高效
资源保护更彻底


压测工具定制化：

针对限流场景设计专用测试脚本
能够有效触发和验证限流机制
提供详细的测试报告和分析


监控体系完整性：

从基础设施到应用层的全栈监控
限流专用监控面板设计
智能告警和故障预警



7.5 学习收获与心得通过本项目的实践，深入理解了：

云原生技术栈：

Docker 容器化技术
Kubernetes 容器编排
微服务架构设计原则


限流算法与实现：

令牌桶算法的原理和应用
分布式限流的挑战和解决方案
多层限流策略的设计思路


DevOps 最佳实践：

CI&#x2F;CD 流水线设计
监控体系建设
自动化测试和部署


性能测试与调优：

压测工具的选择和使用
性能瓶颈的识别和优化
系统扩容策略的验证




8. 附录8.1 项目文件结构yys/├── src/                                    # 源代码目录│   ├── main/java/com/hello/hello/│   │   ├── config/                        # 配置类│   │   │   ├── RateLimitConfig.java      # 限流配置│   │   │   ├── RedisConfig.java          # Redis配置│   │   │   └── WebMvcConfig.java         # Web配置│   │   ├── controller/│   │   │   └── HelloController.java      # 控制器│   │   ├── interceptor/│   │   │   └── RateLimitInterceptor.java # 限流拦截器│   │   ├── service/│   │   │   └── RateLimiterService.java   # 限流服务│   │   └── HelloApplication.java         # 启动类│   └── main/resources/│       └── application.properties        # 应用配置├── jenkins/scripts/                       # K8s部署文件│   ├── prometheus-test-demo.yaml│   └── prometheus-test-serviceMonitor.yaml├── Dockerfile                            # Docker构建文件├── Jenkinsfile                          # Jenkins流水线├── pom.xml                              # Maven配置└── README.md                            # 项目说明文档

8.2 相关技术栈版本
Java: 17
Spring Boot: 3.5.3
Bucket4j: 8.10.1
Redis: 7-alpine
Kubernetes: 1.20+
Docker: 20.10+
Jenkins: 2.400+
Prometheus: 2.40+
Grafana: 9.0+


报告完成时间: 2025年7月20日项目代码仓库: https://github.com/231220075/yys分支: hpa

感谢阅读！如果这篇文章对你有帮助，欢迎点赞和分享。
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>归去来</title>
    <url>/2025/08/09/%E5%BD%92%E5%8E%BB%E6%9D%A5/</url>
    <content><![CDATA[📝 归去来
回看一年前的随笔，情更切。pyq发文，如今补上，仅供纪念。

还是感觉以后回村里隐居也挺好。
​这里只是晋东南群山中的一个小村落，我知道上一次回来是去年暑假，却不知道下一次要到什么时候了。一条马路将村子分成两片，也连接此处与县城，其上来往的公交车司机也成了姥姥姥爷的老熟人。曾几何时公交车并不像现在一样一元通全线，但在这数不清多少年的时间里唯一改变的也只是票价，始终是两位老人入城的主要交通工具。这条公交线很慢，小时候印象里的从村到城1小时至今不变。
​往前回倒十几年，回到村里还没修水泥路，回到一些老人离开之前，印象比较深刻的是那时日常用水还是靠担的。记忆里的三处水井现在只能找到两处，一处后山，一处水库旁，现在自然是荒废了。只有我妈体验过担水，还没等我长大就舍弃了这种原始方式，不过担子倒还留存着，也是某种历史的见证了。​​前几天和姥爷下镇里理发，临返程时正巧下雨，我们俩冒着雨骑摩托车在山路上冲刺，感觉姥爷像施了避雨咒一样，结合我下雨时骑摩托被遮挡视线的经历，简直不可思议。返程之前路人还调侃老人带年轻人，只是这位朋友不明其中缘由，这辆摩托车比我年龄还大，借我姥姥的话，这玩意只有我姥爷驾驭得了。多少年过去了，自从地开始荒废之后拖拉机就不怎么开了，但摩托车仍是姥爷的得力干将，只是不知道他还想骑多少年，又能骑多少年。​​从我有记忆开始两位老人就主要靠种地和养蚕为主要收入，以至于我来到晋北看到那里的农家人甚至没见过蚕时感到惊讶。种地自然没什么好说的，主要就是小麦、玉米、土豆、高粱之类的经济作物，除去自己留一些磨成面和自给，其余便卖作收入。而房子周围两位老人也开垦了数小块土地，种一些萝卜、西红柿、豆角之类的果蔬，省去了天天去镇里买菜了。甚至后来表妹想吃草莓的时候，姥爷也真能在房子背后那片难以称得上是肥沃的土地上给她变出草莓，真的很神奇吧。除了种的田，他们还会打核桃、摘柿子和山楂，甚至会摘桑椹。不知道现在还有多少人知道核桃最外层是青皮的，去皮之后洗净才是棕色的壳。姥姥曾多次念叨村里人都觉得核桃不值钱，而城里人却愿意花较贵的钱去超市称，她表示相当不理解。而摘下的柿子除去现吃的，为了方便保存往往会做成柿饼，至今仍是；山楂则去核做成红果罐头，估计是山楂树虽着地一起荒了，我也已经记不得上一次吃红果罐头是什么时候了。​​不论病逝还是进城，在一些老人没离开前，整个村子都会养蚕。养蚕以季为周期，分春夏秋冬蚕。村里人先统计各家各户的养殖量，以张为单位，那是因为一开始拿回来的蚕籽在粘板上。从一个个小黑点长成白蚕再到结茧，喂桑叶从切成细碎到整叶铺盖，它们的住处也从粘板到数个木篓子，直到喷上药，将它们移到网格栅上，静待结茧。随着不少老人的离开，养蚕人越来越少，在前些年姥姥姥爷也因身体原因不在养蚕，网格栅也终于收进了牛圈，恐怕再无可用之日。​​如今，除了种少许地，姥爷还常常骑车上山采摘连翘（P3）。实际上近些年十里八乡的老年男女都在采这种药来卖钱，以6到9月最为频繁，但价格偏低，几元到十几元一斤上下浮动；冬天的干连翘价高，往往在五六十元一斤，但却难寻。采药人早八晚六地摘，一天下来好的话人均十几斤，不好则只有六七斤。姥姥也常会开玩笑说，今天出去吃顿饭又把姥爷一天的采药钱吃没了，我笑罢只觉得苦涩，但也知道老人是闲不住的。采药人采回药后也要观察行情，但又因为连翘不经放所以也要尽快出手，和各地收药人的搏弈始终存在，但不幸的是今年夏天我姥爷总是在涨价前出手，只能在吃饭时骂几句收药人罢了。今天的采摘量为九斤，行情为十二元每斤，在此记录一下。​​我还是会吐槽两位老人生活的地方：房子都是上个世纪的产物，到冬天特别冷；一把铁勺子从姥姥的母亲传到现在；在村里夏天要时刻盯防蚊子，尤其是上厕所qwq；种几块地还要提防野猪，也总会被拱得粮食减产；现在的日常用水每隔五天统一供应，日常囤水；村子里的人越来越少，现在凑桌麻将都难；不时还有蝎子和蛇出没（前几天我就被蝎子咬了(⁄ ⁄•⁄ω⁄•⁄ ⁄)）。但他们俩丝毫不在意。昨天又谈到我想让他们俩彻底离开这里，常住县城，给小姨做饭带娃，但姥姥仍是不在意。我说你们俩总有干不动的时候，早点下城里享受不好呗，姥姥执意说春夏之际凉快。我又说城里有空调不比村里凉快？她又提到费电了。对，这两位就是这么节俭，省了一辈子，处处细打算，却在两位女儿买房时拿出好几万，每次我回来都去超市割肉买菜，在离开的时候以前是塞钱，现在是转账，也只会告诫我好好学习……​​千反田用来形容她家乡的话也正是这个村子的现状，”这里是我的故乡，只有水和土地，人们也在渐渐衰老，失去活力”。我并不觉得这里是最美的地方，也并不觉得这里充满可能性，但是，我愿意讲述这里过往的点滴。可以预见以姥姥姥爷为代表的一代老人也离开这里后，在未来的三十年间这个村子终将荒无人烟。我不知道其他户人家的后代怎么看，我想我还会回到这里，去寻访过往踪迹。​​写在即将启程却不知何时归来之际。
感谢阅读！如果这篇文章对你有帮助，欢迎点赞和分享。
]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>乡愁</tag>
      </tags>
  </entry>
  <entry>
    <title>🌐 网页构建基础知识详解</title>
    <url>/2025/08/13/%E7%BD%91%E9%A1%B5%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[🌐 网页构建基础知识体系作为一个前端开发的初学者，了解网页构建的完整体系是非常重要的。本文将从专业角度为你系统地解释整个网页开发的基础知识。
1. 前端三剑客 - 网页的基础构成🏗️ HTML (HyperText Markup Language)
作用：网页的骨架和结构
比喻：就像房子的框架，定义了哪里是门、哪里是窗户
核心概念：

&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;页面标题&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;这是标题&lt;/h1&gt;    &lt;p&gt;这是段落&lt;/p&gt;    &lt;div&gt;这是容器&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;

常用HTML标签：

&lt;h1&gt; - &lt;h6&gt;：标题
&lt;p&gt;：段落
&lt;div&gt;：容器
&lt;span&gt;：内联元素
&lt;a&gt;：链接
&lt;img&gt;：图片
&lt;ul&gt;, &lt;ol&gt;, &lt;li&gt;：列表

🎨 CSS (Cascading Style Sheets)
作用：网页的样式和美化
比喻：就像房子的装修，决定颜色、布局、字体等
核心概念：

h1 &#123;  color: blue;  font-size: 24px;  text-align: center;&#125;.container &#123;  width: 100%;  margin: 0 auto;  padding: 20px;&#125;#header &#123;  background-color: #f0f0f0;  border-bottom: 1px solid #ccc;&#125;

CSS选择器类型：

元素选择器：h1, p, div
类选择器：.className
ID选择器：#idName
属性选择器：[type=&quot;text&quot;]

CSS盒模型：
content → padding → border → margin

⚡ JavaScript
作用：网页的交互和动态行为
比喻：就像房子的电器，让一切动起来
核心概念：

// 基础语法function showAlert() &#123;  alert(&#x27;Hello World!&#x27;);&#125;// DOM操作document.getElementById(&#x27;button&#x27;).onclick = showAlert;// 事件监听document.addEventListener(&#x27;DOMContentLoaded&#x27;, function() &#123;  console.log(&#x27;页面加载完成&#x27;);&#125;);// 变量和数据类型let name = &quot;张三&quot;;const age = 25;var isStudent = true;

2. 现代网页开发流程📝 开发阶段源代码编写 → 预处理 → 打包构建 → 部署上线

🔧 构建工具的作用Hexo (静态网站生成器)
将 Markdown 文件转换为 HTML
自动应用主题样式
生成完整的网站结构
支持插件扩展

其他流行工具：
Jekyll：GitHub 原生支持
Hugo：Go 语言编写，速度极快
Gatsby：基于 React 的现代框架
Next.js：全栈 React 框架
Vue Press：基于 Vue 的文档工具

🛠️ 前端工程化工具
包管理器：npm, yarn, pnpm
构建工具：Webpack, Vite, Rollup
CSS预处理器：Sass, Less, Stylus
代码规范：ESLint, Prettier
版本控制：Git, GitHub

3. 博客架构解析📁 目录结构blog/├── source/           # 源文件目录│   ├── _posts/      # 博客文章 (Markdown)│   ├── _drafts/     # 草稿文件│   ├── games/       # 自定义页面│   ├── photos/      # 静态资源│   └── categories/  # 分类页面├── themes/          # 主题文件│   └── butterfly/   # 当前使用的主题├── public/          # 生成的静态网站├── node_modules/    # 依赖包├── _config.yml      # 站点配置文件├── package.json     # 项目依赖配置└── .gitignore       # Git忽略文件

🔄 工作流程
编写内容：在 source/_posts/ 写 Markdown 文章
配置主题：在 _config.yml 和主题配置文件中设置
本地预览：hexo server 启动本地服务器
生成网站：hexo generate 将源文件转换为静态 HTML
部署上线：hexo deploy 发布到 GitHub Pages

📝 Markdown 语法要点# 一级标题## 二级标题### 三级标题**粗体文本***斜体文本*~~删除线~~- 无序列表项1- 无序列表项21. 有序列表项12. 有序列表项2[链接文本](https://example.com)![图片描述](image.jpg)\`\`\`javascript// 代码块console.log(&#x27;Hello World&#x27;);\`\`\`&gt; 引用文本| 表格 | 列1 | 列2 ||------|-----|-----|| 行1  | 数据1 | 数据2 |

4. 部署和托管原理🏠 静态网站 vs 动态网站静态网站（如你的博客）：
特点：预先生成所有 HTML 文件
优势：
加载速度快
安全性高
维护成本低
SEO友好


适用场景：博客、文档、展示类网站

动态网站：
特点：根据用户请求实时生成页面
优势：
交互性强
内容可实时更新
用户个性化体验


适用场景：社交媒体、电商、管理系统

☁️ GitHub Pages 原理本地代码 → Git 推送 → GitHub 仓库 → 自动构建 → CDN分发 → 用户访问

GitHub Pages 优势：

免费托管
自动部署
HTTPS 支持
自定义域名
全球 CDN 加速

🌍 其他托管平台
Netlify：功能强大，支持表单处理
Vercel：专注于前端框架
Surge.sh：简单快速的静态托管
Cloudflare Pages：结合 CDN 优势

5. 网页加载过程详解🌊 浏览器加载流程
DNS 解析：将域名转换为 IP 地址
建立连接：浏览器与服务器建立 TCP 连接
发送请求：HTTP&#x2F;HTTPS 请求网页资源
接收响应：服务器返回 HTML 文档
解析 HTML：构建 DOM 树
加载资源：下载 CSS、JavaScript、图片等
渲染页面：应用样式，执行脚本
完成加载：页面完全可交互

📊 性能优化要点减少文件大小# 图片压缩- 使用 WebP 格式- 适当降低图片质量- 使用响应式图片# 代码压缩- CSS/JS 文件压缩- 移除未使用的代码- 使用 Tree Shaking

减少请求次数
合并 CSS&#x2F;JS 文件
使用 CSS Sprites
内联小文件
启用 HTTP&#x2F;2

缓存策略# HTTP 缓存头Cache-Control: max-age=31536000ETag: &quot;abc123&quot;Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT

CDN 使用
静态资源分发
就近服务用户
减轻源服务器压力

6. 响应式设计原理📱 移动优先设计/* 基础样式（移动端） */.container &#123;  width: 100%;  padding: 10px;&#125;/* 平板端 */@media (min-width: 768px) &#123;  .container &#123;    width: 750px;    margin: 0 auto;  &#125;&#125;/* 桌面端 */@media (min-width: 1200px) &#123;  .container &#123;    width: 1200px;  &#125;&#125;

🎯 响应式断点/* 常用断点 *//* 超小屏幕（手机） */@media (max-width: 575.98px) &#123; ... &#125;/* 小屏幕（手机横屏） */@media (min-width: 576px) and (max-width: 767.98px) &#123; ... &#125;/* 中等屏幕（平板） */@media (min-width: 768px) and (max-width: 991.98px) &#123; ... &#125;/* 大屏幕（桌面） */@media (min-width: 992px) and (max-width: 1199.98px) &#123; ... &#125;/* 超大屏幕（大桌面） */@media (min-width: 1200px) &#123; ... &#125;

🔧 Flexbox 布局.flex-container &#123;  display: flex;  justify-content: space-between;  /* 主轴对齐 */  align-items: center;             /* 交叉轴对齐 */  flex-wrap: wrap;                 /* 换行 */&#125;.flex-item &#123;  flex: 1;        /* 等比伸缩 */  flex-grow: 1;   /* 放大比例 */  flex-shrink: 1; /* 缩小比例 */  flex-basis: 0;  /* 基础大小 */&#125;

🎨 Grid 布局.grid-container &#123;  display: grid;  grid-template-columns: repeat(3, 1fr);  grid-gap: 20px;  grid-template-areas:     &quot;header header header&quot;    &quot;sidebar main main&quot;    &quot;footer footer footer&quot;;&#125;.header &#123; grid-area: header; &#125;.sidebar &#123; grid-area: sidebar; &#125;.main &#123; grid-area: main; &#125;.footer &#123; grid-area: footer; &#125;

7. SEO 和用户体验🔍 搜索引擎优化 (SEO)Meta 标签优化&lt;head&gt;  &lt;title&gt;页面标题 - 网站名称&lt;/title&gt;  &lt;meta name=&quot;description&quot; content=&quot;页面描述，120-160字符&quot;&gt;  &lt;meta name=&quot;keywords&quot; content=&quot;关键词1,关键词2,关键词3&quot;&gt;    &lt;!-- Open Graph (社交分享) --&gt;  &lt;meta property=&quot;og:title&quot; content=&quot;页面标题&quot;&gt;  &lt;meta property=&quot;og:description&quot; content=&quot;页面描述&quot;&gt;  &lt;meta property=&quot;og:image&quot; content=&quot;分享图片URL&quot;&gt;  &lt;meta property=&quot;og:url&quot; content=&quot;页面URL&quot;&gt;    &lt;!-- Twitter Card --&gt;  &lt;meta name=&quot;twitter:card&quot; content=&quot;summary_large_image&quot;&gt;  &lt;meta name=&quot;twitter:title&quot; content=&quot;页面标题&quot;&gt;  &lt;meta name=&quot;twitter:description&quot; content=&quot;页面描述&quot;&gt;&lt;/head&gt;

语义化 HTML&lt;article&gt;  &lt;header&gt;    &lt;h1&gt;文章标题&lt;/h1&gt;    &lt;time datetime=&quot;2025-08-13&quot;&gt;2025年8月13日&lt;/time&gt;  &lt;/header&gt;    &lt;main&gt;    &lt;section&gt;      &lt;h2&gt;章节标题&lt;/h2&gt;      &lt;p&gt;段落内容...&lt;/p&gt;    &lt;/section&gt;  &lt;/main&gt;    &lt;footer&gt;    &lt;p&gt;文章作者信息&lt;/p&gt;  &lt;/footer&gt;&lt;/article&gt;

结构化数据&#123;  &quot;@context&quot;: &quot;https://schema.org&quot;,  &quot;@type&quot;: &quot;Article&quot;,  &quot;headline&quot;: &quot;文章标题&quot;,  &quot;author&quot;: &#123;    &quot;@type&quot;: &quot;Person&quot;,    &quot;name&quot;: &quot;作者姓名&quot;  &#125;,  &quot;datePublished&quot;: &quot;2025-08-13&quot;,  &quot;description&quot;: &quot;文章描述&quot;&#125;

👥 用户体验 (UX) 设计原则可用性原则
一致性：相似功能使用相似设计
可预测性：用户能预期操作结果
容错性：减少错误，方便纠错
效率性：快速完成任务

可访问性 (Accessibility)&lt;!-- 语义化标签 --&gt;&lt;nav aria-label=&quot;主导航&quot;&gt;  &lt;ul&gt;    &lt;li&gt;&lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;/about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;  &lt;/ul&gt;&lt;/nav&gt;&lt;!-- 图片替代文本 --&gt;&lt;img src=&quot;chart.png&quot; alt=&quot;2025年销售数据图表&quot;&gt;&lt;!-- 表单标签 --&gt;&lt;label for=&quot;email&quot;&gt;邮箱地址&lt;/label&gt;&lt;input type=&quot;email&quot; id=&quot;email&quot; required&gt;&lt;!-- 键盘导航 --&gt;&lt;button tabindex=&quot;0&quot;&gt;可键盘访问的按钮&lt;/button&gt;

性能体验
首屏加载时间 &lt; 3秒
页面完全加载 &lt; 5秒
交互响应时间 &lt; 100ms
Core Web Vitals 指标优化

8. 前端框架生态⚛️ React 生态// React 组件示例function BlogPost(&#123; title, content, author &#125;) &#123;  const [likes, setLikes] = useState(0);    return (    &lt;article&gt;      &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;      &lt;p&gt;作者：&#123;author&#125;&lt;/p&gt;      &lt;div&gt;&#123;content&#125;&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; setLikes(likes + 1)&#125;&gt;        点赞 (&#123;likes&#125;)      &lt;/button&gt;    &lt;/article&gt;  );&#125;

React 生态工具：

Create React App：脚手架工具
Next.js：全栈框架
React Router：路由管理
Redux&#x2F;Zustand：状态管理

💚 Vue 生态&lt;!-- Vue 组件示例 --&gt;&lt;template&gt;  &lt;article&gt;    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;    &lt;p&gt;作者：&#123;&#123; author &#125;&#125;&lt;/p&gt;    &lt;div&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;    &lt;button @click=&quot;likes++&quot;&gt;      点赞 (&#123;&#123; likes &#125;&#125;)    &lt;/button&gt;  &lt;/article&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&#x27;title&#x27;, &#x27;content&#x27;, &#x27;author&#x27;],  data() &#123;    return &#123;      likes: 0    &#125;  &#125;&#125;&lt;/script&gt;

Vue 生态工具：

Vue CLI&#x2F;Vite：脚手架工具
Nuxt.js：全栈框架
Vue Router：路由管理
Vuex&#x2F;Pinia：状态管理

🅰️ Angular 生态// Angular 组件示例@Component(&#123;  selector: &#x27;blog-post&#x27;,  template: `    &lt;article&gt;      &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;      &lt;p&gt;作者：&#123;&#123;author&#125;&#125;&lt;/p&gt;      &lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;      &lt;button (click)=&quot;increaseLikes()&quot;&gt;        点赞 (&#123;&#123;likes&#125;&#125;)      &lt;/button&gt;    &lt;/article&gt;  `&#125;)export class BlogPostComponent &#123;  @Input() title: string;  @Input() content: string;  @Input() author: string;    likes = 0;    increaseLikes() &#123;    this.likes++;  &#125;&#125;

9. 后端基础知识🖥️ 服务器端语言
Node.js：JavaScript 运行时
Python：Django, Flask 框架
Java：Spring Boot 框架
PHP：Laravel, Symfony 框架
C#：ASP.NET Core 框架

🗄️ 数据库类型-- SQL 数据库示例 (MySQL)CREATE TABLE posts (  id INT PRIMARY KEY AUTO_INCREMENT,  title VARCHAR(255) NOT NULL,  content TEXT,  author VARCHAR(100),  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);SELECT * FROM posts WHERE author = &#x27;张三&#x27;;

// NoSQL 数据库示例 (MongoDB)&#123;  &quot;_id&quot;: ObjectId(&quot;...&quot;),  &quot;title&quot;: &quot;文章标题&quot;,  &quot;content&quot;: &quot;文章内容&quot;,  &quot;author&quot;: &quot;张三&quot;,  &quot;tags&quot;: [&quot;技术&quot;, &quot;教程&quot;],  &quot;createdAt&quot;: ISODate(&quot;2025-08-13T...&quot;)&#125;

🔌 API 设计// RESTful API 示例GET    /api/posts        // 获取文章列表GET    /api/posts/:id    // 获取单篇文章POST   /api/posts        // 创建文章PUT    /api/posts/:id    // 更新文章DELETE /api/posts/:id    // 删除文章// GraphQL API 示例query &#123;  posts &#123;    id    title    author &#123;      name      email    &#125;  &#125;&#125;

10. 开发工具和环境🛠️ 代码编辑器
VS Code：功能强大，插件丰富
WebStorm：JetBrains 出品
Sublime Text：轻量快速
Atom：GitHub 开源编辑器

📦 包管理器# npm (Node Package Manager)npm install package-namenpm install -g package-name  # 全局安装npm run build               # 运行脚本# yarn (Facebook 开发)yarn add package-nameyarn global add package-nameyarn build# pnpm (性能优化版本)pnpm add package-namepnpm add -g package-namepnpm build

🔧 构建工具// Webpack 配置示例module.exports = &#123;  entry: &#x27;./src/index.js&#x27;,  output: &#123;    path: path.resolve(__dirname, &#x27;dist&#x27;),    filename: &#x27;bundle.js&#x27;  &#125;,  module: &#123;    rules: [      &#123;        test: /\.css$/,        use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;]      &#125;,      &#123;        test: /\.js$/,        use: &#x27;babel-loader&#x27;      &#125;    ]  &#125;&#125;;

// Vite 配置示例import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;export default defineConfig(&#123;  plugins: [vue()],  build: &#123;    outDir: &#x27;dist&#x27;,    minify: &#x27;terser&#x27;  &#125;&#125;)

11. 版本控制和协作📝 Git 基础命令# 基础操作git init                    # 初始化仓库git add .                   # 添加所有文件到暂存区git commit -m &quot;提交信息&quot;    # 提交更改git push origin main        # 推送到远程仓库# 分支操作git branch feature-branch   # 创建分支git checkout feature-branch # 切换分支git merge feature-branch    # 合并分支# 查看状态git status                  # 查看工作区状态git log --oneline          # 查看提交历史git diff                   # 查看差异

🤝 协作工作流主分支 (main/master)├── 开发分支 (develop)│   ├── 功能分支 (feature/login)│   ├── 功能分支 (feature/payment)│   └── 修复分支 (hotfix/bug-001)└── 发布分支 (release/v1.2.0)

📋 提交规范# 提交消息格式&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;# 类型说明feat:     新功能fix:      修复bugdocs:     文档更新style:    代码格式调整refactor: 代码重构test:     测试相关chore:    构建/工具链更新# 示例feat(auth): 添加用户登录功能fix(ui): 修复响应式布局问题docs(readme): 更新安装说明

12. 学习路径和资源推荐📈 初学者路径
第一阶段：HTML + CSS 基础

学会基本标签和样式
完成静态页面制作
掌握响应式设计


第二阶段：JavaScript 基础

语法和数据类型
DOM 操作
事件处理


第三阶段：工具和框架

Git 版本控制
包管理器使用
选择一个框架深入学习


第四阶段：项目实践

个人作品集
小型应用开发
开源项目贡献



📚 学习资源
在线教程：

MDN Web Docs
freeCodeCamp
菜鸟教程
慕课网


视频课程：

Bilibili
腾讯课堂
网易云课堂
YouTube


实践平台：

CodePen
JSFiddle
Repl.it
GitHub



🎯 进阶方向
前端工程化：构建工具、自动化部署
性能优化：加载优化、渲染优化
跨端开发：React Native、Flutter
全栈开发：Node.js、数据库
DevOps：CI&#x2F;CD、容器化

13. 常见问题和解决方案❓ 样式问题/* 常见的 CSS 重置 */* &#123;  margin: 0;  padding: 0;  box-sizing: border-box;&#125;/* 清除浮动 */.clearfix::after &#123;  content: &quot;&quot;;  display: table;  clear: both;&#125;/* 垂直居中 */.center &#123;  display: flex;  justify-content: center;  align-items: center;&#125;

🐛 JavaScript 调试// 控制台调试console.log(&#x27;变量值:&#x27;, variable);console.error(&#x27;错误信息:&#x27;, error);console.table(arrayData);// 断点调试debugger;  // 在此处暂停执行// 错误处理try &#123;  // 可能出错的代码  riskyOperation();&#125; catch (error) &#123;  console.error(&#x27;捕获到错误:&#x27;, error);&#125; finally &#123;  // 总是执行的代码  cleanup();&#125;

🔧 性能问题// 函数防抖function debounce(func, wait) &#123;  let timeout;  return function executedFunction(...args) &#123;    const later = () =&gt; &#123;      clearTimeout(timeout);      func(...args);    &#125;;    clearTimeout(timeout);    timeout = setTimeout(later, wait);  &#125;;&#125;// 函数节流function throttle(func, wait) &#123;  let inThrottle;  return function() &#123;    const args = arguments;    const context = this;    if (!inThrottle) &#123;      func.apply(context, args);      inThrottle = true;      setTimeout(() =&gt; inThrottle = false, wait);    &#125;  &#125;&#125;// 使用示例const debouncedSearch = debounce(searchFunction, 300);const throttledScroll = throttle(scrollHandler, 100);

14. 未来发展趋势🚀 新兴技术
WebAssembly：高性能 Web 应用
PWA：渐进式 Web 应用
JAMstack：现代 Web 架构
Serverless：无服务器计算
边缘计算：CDN 边缘处理

🎨 设计趋势
暗色模式：护眼且时尚
微交互：细致的用户反馈
3D 和动画：沉浸式体验
极简设计：专注内容本身

🛠️ 开发趋势
TypeScript：类型安全的 JavaScript
组件化开发：可复用的 UI 组件
微前端：大型应用的模块化
低代码&#x2F;无代码：可视化开发平台

总结网页构建是一个不断发展的领域，从最基础的 HTML、CSS、JavaScript 到现代的框架和工具链，每一层都有其存在的价值和意义。
🎯 关键要点
基础要扎实：HTML、CSS、JavaScript 是根基
实践要充分：动手做项目比看教程更重要
学习要持续：技术更新快，需要保持学习习惯
视野要开阔：不仅要会写代码，还要了解设计、产品、用户体验

🌟 给初学者的建议
不要急于求成：每个阶段都要打好基础
多做项目：从模仿开始，逐步创新
参与社区：GitHub、Stack Overflow、技术论坛
保持好奇心：关注新技术，但不要盲目追新

希望这份详细的指南能帮助你更好地理解网页构建的全貌，在前端开发的道路上走得更稳更远！

最后更新：2025年8月13日如有疑问，欢迎交流讨论！
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>用rust复刻git</title>
    <url>/2025/08/07/%E7%94%A8rust%E5%A4%8D%E5%88%BBgit/</url>
    <content><![CDATA[📝 用rust复刻git
本文将介绍用rust复刻git的历程，也纪念我第一次合作开发的经历

前言大二下选课的时候发现有一门《rust程序设计》的课程，之前在大一上c++的时候最早接触过rust这个名字，但是一直没怎么了解过，于是抱着好奇心和同伴组队选了这门课，这也是这门项目的由来。
整个项目从4月份开始，到5月底向猪脚答辩时完成了1.0版本（https://github.com/231220075/git.git），包含了除远程分支外的基本功能。后续在暑假期间补上了远程分支控制的部分，即1.1版本（https://github.com/231220075/rit.git），命名为rit-&gt;rust-git。
初步开发
首先需要了解git的工作原理，这一部分参考https://git-scm.com/book/en/v，不再赘述。
每一条git命令执行过程比较固定，解析好命令行参数后执行对应的处理函数即可。解析命令行参数使用clap（易于使用，能处理复杂参数解析，且自动生成help页）。clap解析命令行参数并返回具体类型的 subcommand，并调用其run函数。这里为了后续子命令的实现，我们把.git所在目录路径作为参数传给run，并为-C做了处理。
在做subcommand之前需要先实现一些底层命令，我们做了cat-file、hash-object、write&#x2F;read-tree、update-index、commit-tree、update-ref&amp;&amp;symboloc-ref等等（后两个比较简单，后续直接简化到utils&#x2F;refs作为分支管理工具了），这一部分逐步理清并构建了git的工作环境，如index区、.git文件内容管理、refs管理等等，以及git中 blob、tree、commit这几种object的结构，这些就是git的底层代码，到此为止我们就能完全读懂.git下的所有文件及其功能了。
理解底层代码后剩下的部分就比较简单了，subcommand就是在底层命令的基础上运行的，基本就是组合一下，加上判断处理。比较复杂的可能是checkout和merge，课程对merge要求比较简单，如果有冲突只要显示两个分支哪部分有不同，这部分由另一位成员完成，我不做过多阐述；而checkout主要涉及到切换分支的时间点，workspace、index和ref commit是否一致的问题。我的理解是，如果切换分支前，仅考虑目标文件，index&#x3D;workspace&#x3D;current ref commit，说明不存在未暂存&amp;&amp;未提交的更改，即index和workspace都是clean，这种情况下可以直接切换ref commit,并把目标commit的tree object写入index和更新workspace；否则说明有未暂存||未提交的更改，需要考虑保留这些更改，存在一个“merge”的过程，对于存在冲突的文件以index&#x2F;workspace为准。
这个过程中每一步开发新功能前需要先把频繁使用的method构建一个util，方便后续使用，我们主要是用到很多关于三类object构建和读写、index的读写、文件读写以及压缩、hash和做单元测试的method，构建了相关的utils。谈到unit test，需要感谢我的同伴开发了完整的测试框架，为我们的测试做出来巨大的贡献、巨大的carry，respect！也是rust优秀的单元测试让我这个懒人也愿意开始做测试了，amazing啊qwq。

debug&amp;&amp;踩坑
关于debug，包括两部分。一是客观方面作为课设，猪脚还是做了oj，我们这个项目需要通过测试拿分。猪脚的oj是用脚本做断言测试公开了部分测试和要求，涉及大文件、可执行文件、图片等的测试；另一方面主观上每个subcommand和底层命令我们做了对应的集成测试，主要是交替使用原版git和rust-git检查问题。
大部分bug在检测的过程中就知道哪里有问题，可以快速解决，但有的是认知问题。比较典型的是，index区暂存文件的结构和tree object的文件结构是不一样的，前者是完整的路径，而后者是递归存储的。
另外就是配置了GitHub的CI，name: Rust CI# 触发条件：当代码推送到仓库或创建 Pull Request 时触发on:  push:    branches: [ &#x27;**&#x27; ]jobs:  build-and-test:    runs-on: ubuntu-latest  # 使用最新的 Ubuntu 环境    steps:      # Step 1: 检出代码      - name: Checkout code        uses: actions/checkout@v3      # Step 2: 设置 Rust 工具链      - name: Set up Rust        uses: actions-rs/toolchain@v1        with:          toolchain: stable  # 使用稳定的 Rust 工具链      # Step 3: 运行 cargo test      - name: Run Tests        run: cargo test -- --test-threads=1      # Step 4: 运行 cargo clippy 检查      - name: Run Clippy        run: cargo clippy -- -D warnings  # 将警告视为错误      # （可选）Step 5: 构建项目      - name: Build Project        run: cargo build --release
这样每次提交自动触发测试，虽然每次都要发个邮件提醒有点烦就是了……大概如下

🤖️ 远程分支
进入8月才有时间收拾这个没完成的摊子，想补充的远程分支部分主要是fetch、pull和push三个subcommand，目标是能和GitHub的repo交互更新即可。
我最终选择用https与GitHub传输，虽然传输大文件不稳定，但是本人对https比较熟悉（ssh现阶段就不太考虑了）。fetch主要是获取远程仓库的分支和对应的commit hash，而首先要设定远程传输的仓库URL，所以先实现remote指令设置分支和URL的映射，保存在.git&#x2F;config文件。fetch同样可以指定参数，选择获取所有远程分支还是特定远程分支，然后创建“.git&#x2F;refs&#x2F;remote&#x2F;分支名”文件，记录其commit hash。
而pull则是fetch+merge，先获取远程分支，然后将当前分支与目标分支合并。有一个需要注意的点是，在init后remote add&amp;&amp;pull，此时本地分支因为没有提交过，refs下并没有默认的master&#x2F;main文件，因为没有提交过、没有commit hash，此时要做merge会出现问题，既没有本地分支也没有index区，我之前的实现会merge fail。所以我取巧了一下，如果是初始化之后直接pull的这种情况，直接fetch+checkout到远程分支；而push则协商需要传输的对象，并创建pack文件通过https传输。
需要注意的地方主要有两点：一是pull下来的pack需要解压缩，这个解压缩器的设计需要比较精确，完全理解git的压缩pack的逻辑才能设计足够精确的解压器、才能完全解压出100%的object，否则会丢失部分object产生缺损；二是所有的pack在push上去后都会被GitHub端接收，需要严格遵循格式，我在此过程中有两个问题，tree object的文件组织格式（没错，正是前文提到的）和index&amp;&amp;tree object中表项没按字典序排序。说实话之前在和原版git比对的时候也注意到了这个顺序问题，但当时感觉没什么影响，现在被教训了，只能说一切都有其存在的意义


感谢阅读！如果这篇文章对你有帮助，欢迎点赞和分享。
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>rust</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>我的博客重新开始</title>
    <url>/2025/08/07/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[🌟 我的博客重新开始大家好！我是 forever，欢迎来到我重新搭建的博客 “Summer Flower”。
📝 为什么重新开始？经过一段时间的思考，我决定重新整理我的博客，主要原因包括：

更好的技术栈: 使用 Hexo + Butterfly 主题，提供更好的阅读体验
规范的内容管理: 建立更完善的写作和发布流程
专注的内容方向: 
💻 技术学习心得
📸 摄影作品分享
🎓 计算机科学学习记录
🌱 日常生活感悟



🛠️ 技术栈介绍这个博客使用的技术栈：

静态网站生成器: Hexo 7.3.0
主题: Butterfly 5.3.3
部署平台: GitHub Pages
域名: 华为云自定义域名
评论系统: Gitalk
统计分析: Google Analytics + 不蒜子

🎯 未来计划接下来我计划在这里分享：
技术内容
Rust 编程学习心得
Git 深度使用技巧
前端开发经验
计算机科学课程笔记

生活分享
摄影作品和技巧
读书心得体会
旅行见闻
日常思考

项目展示
GitHub 开源项目介绍
个人项目经验分享
课程作业总结

💡 写作理念我希望这个博客能够：

记录成长: 记录学习和生活中的点点滴滴
分享经验: 把学到的知识和经验分享给大家
交流互动: 通过博客认识更多志同道合的朋友
持续学习: 通过写作来深化自己的理解

🤝 联系方式如果你对我的文章有任何想法或建议，欢迎通过以下方式联系我：

📧 Email: 231220075@smail.nju.edu.cn
🐙 GitHub: @231220075
💬 评论区: 每篇文章下方都可以留言

🎉 结语感谢你阅读到这里！希望我的博客能为你带来一些有价值的内容。
让我们一起在这个夏日花园里，记录美好，分享成长！🌸

“每一次重新开始，都是向更好的自己迈进一步。”
]]></content>
      <categories>
        <category>生活随想</category>
      </categories>
      <tags>
        <tag>start</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐和视频播放测试</title>
    <url>/2025/08/09/%E9%9F%B3%E4%B9%90%E5%92%8C%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[🎵 音乐播放功能方式一：HTML5 Audio 标签直接嵌入音频文件&lt;audio controls&gt;  &lt;source src=&quot;/music/song.mp3&quot; type=&quot;audio/mpeg&quot;&gt;  &lt;source src=&quot;/music/song.ogg&quot; type=&quot;audio/ogg&quot;&gt;  您的浏览器不支持音频播放。&lt;/audio&gt;


  
  
  您的浏览器不支持音频播放。


方式二：嵌入网易云音乐&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot;         src=&quot;//music.163.com/outchain/player?type=2&amp;id=28391863&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;





🎬 视频播放功能方式一：HTML5 Video 标签本地视频文件&lt;video width=&quot;100%&quot; controls&gt;  &lt;source src=&quot;/videos/demo.mp4&quot; type=&quot;video/mp4&quot;&gt;  您的浏览器不支持视频播放。&lt;/video&gt;


  
  您的浏览器不支持视频播放。


方式二：嵌入 YouTube 视频iframe 嵌入&lt;iframe width=&quot;100%&quot; height=&quot;400&quot;         src=&quot;https://www.youtube.com/embed/VIDEO_ID&quot;         frameborder=&quot;0&quot;         allowfullscreen&gt;&lt;/iframe&gt;




方式三：嵌入 Bilibili 视频B站视频嵌入静态嵌入示例&lt;iframe src=&quot;//player.bilibili.com/player.html?bvid=BV1xx411c7mD&amp;page=1&quot;         scrolling=&quot;no&quot;         border=&quot;0&quot;         frameborder=&quot;no&quot;         framespacing=&quot;0&quot;         allowfullscreen=&quot;true&quot;         width=&quot;100%&quot;         height=&quot;400&quot;&gt;&lt;/iframe&gt;




🎮 交互式B站视频播放器&lt;div class=&quot;bilibili-player-container&quot;&gt;  &lt;div class=&quot;input-section&quot;&gt;    &lt;label for=&quot;bvid-input&quot;&gt;输入B站视频BV号：&lt;/label&gt;    &lt;div class=&quot;input-group&quot;&gt;      &lt;input type=&quot;text&quot;              id=&quot;bvid-input&quot;              placeholder=&quot;例如：BV1om4y1Y771&quot;              value=&quot;BV1om4y1Y771&quot;&gt;      &lt;button onclick=&quot;loadBilibiliVideo()&quot;&gt;🎬 播放视频&lt;/button&gt;      &lt;button onclick=&quot;clearVideo()&quot;&gt;🗑️ 清空&lt;/button&gt;    &lt;/div&gt;    &lt;div class=&quot;preset-videos&quot;&gt;      &lt;span&gt;快速选择：&lt;/span&gt;      &lt;button onclick=&quot;loadPresetVideo(&#x27;BV1om4y1Y771&#x27;)&quot;&gt;示例视频1&lt;/button&gt;      &lt;button onclick=&quot;loadPresetVideo(&#x27;BV1xx411c7mD&#x27;)&quot;&gt;示例视频2&lt;/button&gt;      &lt;button onclick=&quot;loadPresetVideo(&#x27;BV1uv411q7Mv&#x27;)&quot;&gt;示例视频3&lt;/button&gt;    &lt;/div&gt;  &lt;/div&gt;    &lt;div class=&quot;video-player&quot;&gt;    &lt;iframe id=&quot;bilibili-iframe&quot;             src=&quot;//player.bilibili.com/player.html?bvid=BV1om4y1Y771&amp;page=1&quot;             scrolling=&quot;no&quot;             border=&quot;0&quot;             frameborder=&quot;no&quot;             framespacing=&quot;0&quot;             allowfullscreen=&quot;true&quot;             width=&quot;100%&quot;             height=&quot;400&quot;&gt;    &lt;/iframe&gt;  &lt;/div&gt;    &lt;div class=&quot;video-info&quot; id=&quot;video-info&quot;&gt;    &lt;p&gt;当前播放：BV1om4y1Y771&lt;/p&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;function loadBilibiliVideo() &#123;  const bvidInput = document.getElementById(&#x27;bvid-input&#x27;);  const iframe = document.getElementById(&#x27;bilibili-iframe&#x27;);  const videoInfo = document.getElementById(&#x27;video-info&#x27;);    let bvid = bvidInput.value.trim();    // 验证BV号格式  if (!bvid) &#123;    alert(&#x27;请输入BV号！&#x27;);    return;  &#125;    // 自动添加BV前缀（如果用户没有输入）  if (!bvid.startsWith(&#x27;BV&#x27;)) &#123;    bvid = &#x27;BV&#x27; + bvid;  &#125;    // 验证BV号格式（简单验证）  const bvidPattern = /^BV[a-zA-Z0-9]&#123;10&#125;$/;  if (!bvidPattern.test(bvid)) &#123;    alert(&#x27;BV号格式不正确！请检查输入（例如：BV1om4y1Y771）&#x27;);    return;  &#125;    // 更新iframe src  const newSrc = `//player.bilibili.com/player.html?bvid=$&#123;bvid&#125;&amp;page=1`;  iframe.src = newSrc;    // 更新视频信息  videoInfo.innerHTML = `&lt;p&gt;当前播放：$&#123;bvid&#125; &lt;span class=&quot;loading&quot;&gt;加载中...&lt;/span&gt;&lt;/p&gt;`;    // 3秒后移除加载提示  setTimeout(() =&gt; &#123;    videoInfo.innerHTML = `&lt;p&gt;当前播放：$&#123;bvid&#125; &lt;span class=&quot;success&quot;&gt;✅ 加载完成&lt;/span&gt;&lt;/p&gt;`;  &#125;, 3000);&#125;function loadPresetVideo(bvid) &#123;  const bvidInput = document.getElementById(&#x27;bvid-input&#x27;);  bvidInput.value = bvid;  loadBilibiliVideo();&#125;function clearVideo() &#123;  const bvidInput = document.getElementById(&#x27;bvid-input&#x27;);  const iframe = document.getElementById(&#x27;bilibili-iframe&#x27;);  const videoInfo = document.getElementById(&#x27;video-info&#x27;);    bvidInput.value = &#x27;&#x27;;  iframe.src = &#x27;about:blank&#x27;;  videoInfo.innerHTML = &#x27;&lt;p&gt;请输入BV号来播放视频&lt;/p&gt;&#x27;;&#125;// 回车键快捷播放document.getElementById(&#x27;bvid-input&#x27;).addEventListener(&#x27;keypress&#x27;, function(e) &#123;  if (e.key === &#x27;Enter&#x27;) &#123;    loadBilibiliVideo();  &#125;&#125;);&lt;/script&gt;&lt;style&gt;.bilibili-player-container &#123;  max-width: 800px;  margin: 20px auto;  padding: 20px;  border: 2px solid #00A1D6;  border-radius: 12px;  background: linear-gradient(135deg, #f8f9ff 0%, #e8f4ff 100%);  box-shadow: 0 4px 12px rgba(0, 161, 214, 0.1);&#125;.input-section &#123;  margin-bottom: 20px;&#125;.input-section label &#123;  display: block;  margin-bottom: 8px;  font-weight: bold;  color: #333;&#125;.input-group &#123;  display: flex;  gap: 10px;  margin-bottom: 15px;  flex-wrap: wrap;&#125;.input-group input &#123;  flex: 1;  min-width: 200px;  padding: 10px 15px;  border: 2px solid #ddd;  border-radius: 6px;  font-size: 14px;  transition: border-color 0.3s;&#125;.input-group input:focus &#123;  outline: none;  border-color: #00A1D6;  box-shadow: 0 0 0 3px rgba(0, 161, 214, 0.1);&#125;.input-group button &#123;  padding: 10px 20px;  background: #00A1D6;  color: white;  border: none;  border-radius: 6px;  cursor: pointer;  font-size: 14px;  font-weight: bold;  transition: all 0.3s;  white-space: nowrap;&#125;.input-group button:hover &#123;  background: #0088BB;  transform: translateY(-1px);&#125;.input-group button:last-child &#123;  background: #FF6B6B;&#125;.input-group button:last-child:hover &#123;  background: #FF5252;&#125;.preset-videos &#123;  display: flex;  align-items: center;  gap: 10px;  flex-wrap: wrap;&#125;.preset-videos span &#123;  color: #666;  font-size: 14px;&#125;.preset-videos button &#123;  padding: 6px 12px;  background: #f0f0f0;  color: #333;  border: 1px solid #ddd;  border-radius: 4px;  cursor: pointer;  font-size: 12px;  transition: all 0.3s;&#125;.preset-videos button:hover &#123;  background: #00A1D6;  color: white;  border-color: #00A1D6;&#125;.video-player &#123;  margin-bottom: 15px;  border-radius: 8px;  overflow: hidden;  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);&#125;.video-info &#123;  text-align: center;  padding: 10px;  background: rgba(255, 255, 255, 0.8);  border-radius: 6px;&#125;.video-info p &#123;  margin: 0;  color: #333;&#125;.loading &#123;  color: #FF9800;  animation: pulse 1.5s infinite;&#125;.success &#123;  color: #4CAF50;&#125;@keyframes pulse &#123;  0%, 50%, 100% &#123; opacity: 1; &#125;  25%, 75% &#123; opacity: 0.5; &#125;&#125;@media (max-width: 600px) &#123;  .input-group &#123;    flex-direction: column;  &#125;    .input-group input &#123;    min-width: auto;  &#125;    .preset-videos &#123;    flex-direction: column;    align-items: flex-start;  &#125;&#125;&lt;/style&gt;




  
    输入B站视频BV号：
    
      
      🎬 播放视频
      🗑️ 清空
    
    
      快速选择：
      示例视频1
      示例视频2
      示例视频3
    
  
  
  
    
    
  
  
  
    当前播放：BV1om4y1Y771
  



function loadBilibiliVideo() {
  const bvidInput = document.getElementById('bvid-input');
  const iframe = document.getElementById('bilibili-iframe');
  const videoInfo = document.getElementById('video-info');
  
  let bvid = bvidInput.value.trim();
  
  // 验证BV号格式
  if (!bvid) {
    alert('请输入BV号！');
    return;
  }
  
  // 自动添加BV前缀（如果用户没有输入）
  if (!bvid.startsWith('BV')) {
    bvid = 'BV' + bvid;
  }
  
  // 验证BV号格式（简单验证）
  const bvidPattern = /^BV[a-zA-Z0-9]{10}$/;
  if (!bvidPattern.test(bvid)) {
    alert('BV号格式不正确！请检查输入（例如：BV1om4y1Y771）');
    return;
  }
  
  // 更新iframe src
  const newSrc = `//player.bilibili.com/player.html?bvid=${bvid}&page=1`;
  iframe.src = newSrc;
  
  // 更新视频信息
  videoInfo.innerHTML = `当前播放：${bvid} 加载中...`;
  
  // 3秒后移除加载提示
  setTimeout(() => {
    videoInfo.innerHTML = `当前播放：${bvid} ✅ 加载完成`;
  }, 3000);
}

function loadPresetVideo(bvid) {
  const bvidInput = document.getElementById('bvid-input');
  bvidInput.value = bvid;
  loadBilibiliVideo();
}

function clearVideo() {
  const bvidInput = document.getElementById('bvid-input');
  const iframe = document.getElementById('bilibili-iframe');
  const videoInfo = document.getElementById('video-info');
  
  bvidInput.value = '';
  iframe.src = 'about:blank';
  videoInfo.innerHTML = '请输入BV号来播放视频';
}

// 回车键快捷播放
document.getElementById('bvid-input').addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    loadBilibiliVideo();
  }
});



.bilibili-player-container {
  max-width: 800px;
  margin: 20px auto;
  padding: 20px;
  border: 2px solid #00A1D6;
  border-radius: 12px;
  background: linear-gradient(135deg, #f8f9ff 0%, #e8f4ff 100%);
  box-shadow: 0 4px 12px rgba(0, 161, 214, 0.1);
}

.input-section {
  margin-bottom: 20px;
}

.input-section label {
  display: block;
  margin-bottom: 8px;
  font-weight: bold;
  color: #333;
}

.input-group {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  flex-wrap: wrap;
}

.input-group input {
  flex: 1;
  min-width: 200px;
  padding: 10px 15px;
  border: 2px solid #ddd;
  border-radius: 6px;
  font-size: 14px;
  transition: border-color 0.3s;
}

.input-group input:focus {
  outline: none;
  border-color: #00A1D6;
  box-shadow: 0 0 0 3px rgba(0, 161, 214, 0.1);
}

.input-group button {
  padding: 10px 20px;
  background: #00A1D6;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s;
  white-space: nowrap;
}

.input-group button:hover {
  background: #0088BB;
  transform: translateY(-1px);
}

.input-group button:last-child {
  background: #FF6B6B;
}

.input-group button:last-child:hover {
  background: #FF5252;
}

.preset-videos {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.preset-videos span {
  color: #666;
  font-size: 14px;
}

.preset-videos button {
  padding: 6px 12px;
  background: #f0f0f0;
  color: #333;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.3s;
}

.preset-videos button:hover {
  background: #00A1D6;
  color: white;
  border-color: #00A1D6;
}

.video-player {
  margin-bottom: 15px;
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.video-info {
  text-align: center;
  padding: 10px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 6px;
}

.video-info p {
  margin: 0;
  color: #333;
}

.loading {
  color: #FF9800;
  animation: pulse 1.5s infinite;
}

.success {
  color: #4CAF50;
}

@keyframes pulse {
  0%, 50%, 100% { opacity: 1; }
  25%, 75% { opacity: 0.5; }
}

@media (max-width: 600px) {
  .input-group {
    flex-direction: column;
  }
  
  .input-group input {
    min-width: auto;
  }
  
  .preset-videos {
    flex-direction: column;
    align-items: flex-start;
  }
}




🎨 高级自定义JavaScript 自定义播放器&lt;div id=&quot;custom-player&quot;&gt;  &lt;video id=&quot;myVideo&quot; width=&quot;100%&quot; height=&quot;400&quot;&gt;    &lt;source src=&quot;/videos/demo.mp4&quot; type=&quot;video/mp4&quot;&gt;  &lt;/video&gt;  &lt;div class=&quot;controls&quot;&gt;    &lt;button onclick=&quot;playPause()&quot;&gt;播放/暂停&lt;/button&gt;    &lt;button onclick=&quot;makeBig()&quot;&gt;放大&lt;/button&gt;    &lt;button onclick=&quot;makeSmall()&quot;&gt;缩小&lt;/button&gt;    &lt;button onclick=&quot;makeNormal()&quot;&gt;正常&lt;/button&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script&gt;var myVideo = document.getElementById(&quot;myVideo&quot;);function playPause() &#123;  if (myVideo.paused) &#123;    myVideo.play();  &#125; else &#123;    myVideo.pause();  &#125;&#125;function makeBig() &#123;  myVideo.width = 800;&#125;function makeSmall() &#123;  myVideo.width = 320;&#125;function makeNormal() &#123;  myVideo.width = 560;&#125;&lt;/script&gt;&lt;style&gt;#custom-player &#123;  text-align: center;  margin: 20px 0;&#125;.controls &#123;  margin-top: 10px;&#125;.controls button &#123;  margin: 0 5px;  padding: 8px 16px;  background: #42A5F5;  color: white;  border: none;  border-radius: 4px;  cursor: pointer;&#125;.controls button:hover &#123;  background: #1976D2;&#125;&lt;/style&gt;

响应式视频容器&lt;div class=&quot;video-container&quot;&gt;  &lt;iframe src=&quot;https://www.youtube.com/embed/dQw4w9WgXcQ&quot;           frameborder=&quot;0&quot;           allowfullscreen&gt;  &lt;/iframe&gt;&lt;/div&gt;&lt;style&gt;.video-container &#123;  position: relative;  padding-bottom: 56.25%; /* 16:9 */  height: 0;  overflow: hidden;&#125;.video-container iframe &#123;  position: absolute;  top: 0;  left: 0;  width: 100%;  height: 100%;&#125;&lt;/style&gt;
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
